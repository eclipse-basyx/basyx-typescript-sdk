/* tslint:disable */
/* eslint-disable */
/**
 * DotAAS Part 2 | HTTP/REST | Submodel Repository Service Specification
 * The entire Submodel Repository Service Specification as part of the [Specification of the Asset Administration Shell: Part 2](https://industrialdigitaltwin.org/en/content-hub/aasspecifications).   Copyright: Industrial Digital Twin Association (IDTA) 2025
 *
 * The version of the OpenAPI document: V3.1.0_SSP-001
 * Contact: info@idtwin.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../../runtime';
import type {
  BaseOperationResult,
  GetPathItemsResult,
  GetReferencesResult,
  GetSubmodelElementsMetadataResult,
  GetSubmodelElementsResult,
  GetSubmodelElementsValueResult,
  GetSubmodelsMetadataResult,
  GetSubmodelsResult,
  GetSubmodelsValueResult,
  OperationRequest,
  OperationRequestValueOnly,
  OperationResult,
  OperationResultValueOnly,
  Reference,
  Result,
  Submodel,
  SubmodelElement,
  SubmodelElementMetadata,
  SubmodelElementValue,
  SubmodelMetadata,
} from '../models/index';

export interface DeleteFileByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
}

export interface DeleteSubmodelByIdRequest {
    submodelIdentifier: string;
}

export interface DeleteSubmodelElementByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
}

export interface GetAllSubmodelElementsRequest {
    submodelIdentifier: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelElementsLevelEnum;
    extent?: GetAllSubmodelElementsExtentEnum;
}

export interface GetAllSubmodelElementsMetadataSubmodelRepoRequest {
    submodelIdentifier: string;
    limit?: number;
    cursor?: string;
}

export interface GetAllSubmodelElementsPathSubmodelRepoRequest {
    submodelIdentifier: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelElementsPathSubmodelRepoLevelEnum;
}

export interface GetAllSubmodelElementsReferenceSubmodelRepoRequest {
    submodelIdentifier: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelElementsReferenceSubmodelRepoLevelEnum;
}

export interface GetAllSubmodelElementsValueOnlySubmodelRepoRequest {
    submodelIdentifier: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelElementsValueOnlySubmodelRepoLevelEnum;
    extent?: GetAllSubmodelElementsValueOnlySubmodelRepoExtentEnum;
}

export interface GetAllSubmodelsRequest {
    semanticId?: string;
    idShort?: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelsLevelEnum;
    extent?: GetAllSubmodelsExtentEnum;
}

export interface GetAllSubmodelsMetadataRequest {
    semanticId?: string;
    idShort?: string;
    limit?: number;
    cursor?: string;
}

export interface GetAllSubmodelsPathRequest {
    semanticId?: string;
    idShort?: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelsPathLevelEnum;
}

export interface GetAllSubmodelsReferenceRequest {
    semanticId?: string;
    idShort?: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelsReferenceLevelEnum;
}

export interface GetAllSubmodelsValueOnlyRequest {
    semanticId?: string;
    idShort?: string;
    limit?: number;
    cursor?: string;
    level?: GetAllSubmodelsValueOnlyLevelEnum;
    extent?: GetAllSubmodelsValueOnlyExtentEnum;
}

export interface GetFileByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
}

export interface GetOperationAsyncResultRequest {
    submodelIdentifier: string;
    idShortPath: string;
    handleId: string;
}

export interface GetOperationAsyncResultValueOnlyRequest {
    submodelIdentifier: string;
    idShortPath: string;
    handleId: string;
}

export interface GetOperationAsyncStatusRequest {
    submodelIdentifier: string;
    idShortPath: string;
    handleId: string;
}

export interface GetSubmodelByIdRequest {
    submodelIdentifier: string;
    level?: GetSubmodelByIdLevelEnum;
    extent?: GetSubmodelByIdExtentEnum;
}

export interface GetSubmodelByIdMetadataRequest {
    submodelIdentifier: string;
}

export interface GetSubmodelByIdPathRequest {
    submodelIdentifier: string;
    level?: GetSubmodelByIdPathLevelEnum;
}

export interface GetSubmodelByIdReferenceRequest {
    submodelIdentifier: string;
}

export interface GetSubmodelByIdValueOnlyRequest {
    submodelIdentifier: string;
    level?: GetSubmodelByIdValueOnlyLevelEnum;
    extent?: GetSubmodelByIdValueOnlyExtentEnum;
}

export interface GetSubmodelElementByPathMetadataSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
}

export interface GetSubmodelElementByPathPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    level?: GetSubmodelElementByPathPathSubmodelRepoLevelEnum;
}

export interface GetSubmodelElementByPathReferenceSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
}

export interface GetSubmodelElementByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    level?: GetSubmodelElementByPathSubmodelRepoLevelEnum;
    extent?: GetSubmodelElementByPathSubmodelRepoExtentEnum;
}

export interface GetSubmodelElementByPathValueOnlySubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    level?: GetSubmodelElementByPathValueOnlySubmodelRepoLevelEnum;
    extent?: GetSubmodelElementByPathValueOnlySubmodelRepoExtentEnum;
}

export interface InvokeOperationAsyncRequest {
    submodelIdentifier: string;
    idShortPath: string;
    operationRequest: OperationRequest;
}

export interface InvokeOperationAsyncValueOnlyRequest {
    aasIdentifier: string;
    submodelIdentifier: string;
    idShortPath: string;
    operationRequestValueOnly: OperationRequestValueOnly;
}

export interface InvokeOperationSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    operationRequest: OperationRequest;
}

export interface InvokeOperationValueOnlyRequest {
    aasIdentifier: string;
    submodelIdentifier: string;
    idShortPath: string;
    operationRequestValueOnly: OperationRequestValueOnly;
}

export interface PatchSubmodelByIdRequest {
    submodelIdentifier: string;
    submodel: Submodel;
    level?: PatchSubmodelByIdLevelEnum;
}

export interface PatchSubmodelByIdMetadataRequest {
    submodelIdentifier: string;
    submodelMetadata: SubmodelMetadata;
    level?: PatchSubmodelByIdMetadataLevelEnum;
}

export interface PatchSubmodelByIdValueOnlyRequest {
    submodelIdentifier: string;
    body: object;
    level?: PatchSubmodelByIdValueOnlyLevelEnum;
}

export interface PatchSubmodelElementByPathMetadataSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    submodelElementMetadata: SubmodelElementMetadata;
}

export interface PatchSubmodelElementByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    submodelElement: SubmodelElement;
    level?: PatchSubmodelElementByPathSubmodelRepoLevelEnum;
}

export interface PatchSubmodelElementByPathValueOnlySubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    submodelElementValue: SubmodelElementValue;
    level?: PatchSubmodelElementByPathValueOnlySubmodelRepoLevelEnum;
}

export interface PostSubmodelRequest {
    submodel: Submodel;
}

export interface PostSubmodelElementByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    submodelElement: SubmodelElement;
}

export interface PostSubmodelElementSubmodelRepoRequest {
    submodelIdentifier: string;
    submodelElement: SubmodelElement;
}

export interface PutFileByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    fileName?: string;
    file?: Blob;
}

export interface PutSubmodelByIdRequest {
    submodelIdentifier: string;
    submodel: Submodel;
}

export interface PutSubmodelElementByPathSubmodelRepoRequest {
    submodelIdentifier: string;
    idShortPath: string;
    submodelElement: SubmodelElement;
    level?: PutSubmodelElementByPathSubmodelRepoLevelEnum;
}

/**
 * 
 */
export class SubmodelRepositoryAPIApi extends runtime.BaseAPI {

    /**
     * Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     */
    async deleteFileByPathSubmodelRepoRaw(requestParameters: DeleteFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling deleteFileByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling deleteFileByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     */
    async deleteFileByPathSubmodelRepo(requestParameters: DeleteFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFileByPathSubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a Submodel
     */
    async deleteSubmodelByIdRaw(requestParameters: DeleteSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling deleteSubmodelById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a Submodel
     */
    async deleteSubmodelById(requestParameters: DeleteSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSubmodelByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a submodel element at a specified path within the submodel elements hierarchy
     */
    async deleteSubmodelElementByPathSubmodelRepoRaw(requestParameters: DeleteSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a submodel element at a specified path within the submodel elements hierarchy
     */
    async deleteSubmodelElementByPathSubmodelRepo(requestParameters: DeleteSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSubmodelElementByPathSubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Returns all submodel elements including their hierarchy
     */
    async getAllSubmodelElementsRaw(requestParameters: GetAllSubmodelElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelElementsResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getAllSubmodelElements().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all submodel elements including their hierarchy
     */
    async getAllSubmodelElements(requestParameters: GetAllSubmodelElementsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelElementsResult> {
        const response = await this.getAllSubmodelElementsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the metadata attributes of all submodel elements including their hierarchy
     */
    async getAllSubmodelElementsMetadataSubmodelRepoRaw(requestParameters: GetAllSubmodelElementsMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelElementsMetadataResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getAllSubmodelElementsMetadataSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/$metadata`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the metadata attributes of all submodel elements including their hierarchy
     */
    async getAllSubmodelElementsMetadataSubmodelRepo(requestParameters: GetAllSubmodelElementsMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelElementsMetadataResult> {
        const response = await this.getAllSubmodelElementsMetadataSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all submodel elements including their hierarchy in the Path notation
     */
    async getAllSubmodelElementsPathSubmodelRepoRaw(requestParameters: GetAllSubmodelElementsPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPathItemsResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getAllSubmodelElementsPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/$path`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all submodel elements including their hierarchy in the Path notation
     */
    async getAllSubmodelElementsPathSubmodelRepo(requestParameters: GetAllSubmodelElementsPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPathItemsResult> {
        const response = await this.getAllSubmodelElementsPathSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the References of all submodel elements
     */
    async getAllSubmodelElementsReferenceSubmodelRepoRaw(requestParameters: GetAllSubmodelElementsReferenceSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReferencesResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getAllSubmodelElementsReferenceSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/$reference`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the References of all submodel elements
     */
    async getAllSubmodelElementsReferenceSubmodelRepo(requestParameters: GetAllSubmodelElementsReferenceSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReferencesResult> {
        const response = await this.getAllSubmodelElementsReferenceSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all submodel elements including their hierarchy in the ValueOnly representation
     */
    async getAllSubmodelElementsValueOnlySubmodelRepoRaw(requestParameters: GetAllSubmodelElementsValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelElementsValueResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getAllSubmodelElementsValueOnlySubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all submodel elements including their hierarchy in the ValueOnly representation
     */
    async getAllSubmodelElementsValueOnlySubmodelRepo(requestParameters: GetAllSubmodelElementsValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelElementsValueResult> {
        const response = await this.getAllSubmodelElementsValueOnlySubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all Submodels
     */
    async getAllSubmodelsRaw(requestParameters: GetAllSubmodelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelsResult>> {
        const queryParameters: any = {};

        if (requestParameters['semanticId'] != null) {
            queryParameters['semanticId'] = requestParameters['semanticId'];
        }

        if (requestParameters['idShort'] != null) {
            queryParameters['idShort'] = requestParameters['idShort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all Submodels
     */
    async getAllSubmodels(requestParameters: GetAllSubmodelsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelsResult> {
        const response = await this.getAllSubmodelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the metadata attributes of all Submodels
     */
    async getAllSubmodelsMetadataRaw(requestParameters: GetAllSubmodelsMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelsMetadataResult>> {
        const queryParameters: any = {};

        if (requestParameters['semanticId'] != null) {
            queryParameters['semanticId'] = requestParameters['semanticId'];
        }

        if (requestParameters['idShort'] != null) {
            queryParameters['idShort'] = requestParameters['idShort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/$metadata`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the metadata attributes of all Submodels
     */
    async getAllSubmodelsMetadata(requestParameters: GetAllSubmodelsMetadataRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelsMetadataResult> {
        const response = await this.getAllSubmodelsMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all Submodels in the Path notation
     */
    async getAllSubmodelsPathRaw(requestParameters: GetAllSubmodelsPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPathItemsResult>> {
        const queryParameters: any = {};

        if (requestParameters['semanticId'] != null) {
            queryParameters['semanticId'] = requestParameters['semanticId'];
        }

        if (requestParameters['idShort'] != null) {
            queryParameters['idShort'] = requestParameters['idShort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/$path`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all Submodels in the Path notation
     */
    async getAllSubmodelsPath(requestParameters: GetAllSubmodelsPathRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPathItemsResult> {
        const response = await this.getAllSubmodelsPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the References for all Submodels
     */
    async getAllSubmodelsReferenceRaw(requestParameters: GetAllSubmodelsReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetReferencesResult>> {
        const queryParameters: any = {};

        if (requestParameters['semanticId'] != null) {
            queryParameters['semanticId'] = requestParameters['semanticId'];
        }

        if (requestParameters['idShort'] != null) {
            queryParameters['idShort'] = requestParameters['idShort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/$reference`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the References for all Submodels
     */
    async getAllSubmodelsReference(requestParameters: GetAllSubmodelsReferenceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetReferencesResult> {
        const response = await this.getAllSubmodelsReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all Submodels in their ValueOnly representation
     */
    async getAllSubmodelsValueOnlyRaw(requestParameters: GetAllSubmodelsValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSubmodelsValueResult>> {
        const queryParameters: any = {};

        if (requestParameters['semanticId'] != null) {
            queryParameters['semanticId'] = requestParameters['semanticId'];
        }

        if (requestParameters['idShort'] != null) {
            queryParameters['idShort'] = requestParameters['idShort'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/$value`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all Submodels in their ValueOnly representation
     */
    async getAllSubmodelsValueOnly(requestParameters: GetAllSubmodelsValueOnlyRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSubmodelsValueResult> {
        const response = await this.getAllSubmodelsValueOnlyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Downloads file content from a specific submodel element from the Submodel at a specified path
     */
    async getFileByPathSubmodelRepoRaw(requestParameters: GetFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getFileByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getFileByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Downloads file content from a specific submodel element from the Submodel at a specified path
     */
    async getFileByPathSubmodelRepo(requestParameters: GetFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.getFileByPathSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Operation result of an asynchronously invoked Operation
     */
    async getOperationAsyncResultRaw(requestParameters: GetOperationAsyncResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getOperationAsyncResult().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getOperationAsyncResult().'
            );
        }

        if (requestParameters['handleId'] == null) {
            throw new runtime.RequiredError(
                'handleId',
                'Required parameter "handleId" was null or undefined when calling getOperationAsyncResult().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))).replace(`{${"handleId"}}`, encodeURIComponent(String(requestParameters['handleId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the Operation result of an asynchronously invoked Operation
     */
    async getOperationAsyncResult(requestParameters: GetOperationAsyncResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResult> {
        const response = await this.getOperationAsyncResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Operation result of an asynchronously invoked Operation
     */
    async getOperationAsyncResultValueOnlyRaw(requestParameters: GetOperationAsyncResultValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResultValueOnly>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getOperationAsyncResultValueOnly().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getOperationAsyncResultValueOnly().'
            );
        }

        if (requestParameters['handleId'] == null) {
            throw new runtime.RequiredError(
                'handleId',
                'Required parameter "handleId" was null or undefined when calling getOperationAsyncResultValueOnly().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))).replace(`{${"handleId"}}`, encodeURIComponent(String(requestParameters['handleId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the Operation result of an asynchronously invoked Operation
     */
    async getOperationAsyncResultValueOnly(requestParameters: GetOperationAsyncResultValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResultValueOnly> {
        const response = await this.getOperationAsyncResultValueOnlyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the status of an asynchronously invoked Operation
     */
    async getOperationAsyncStatusRaw(requestParameters: GetOperationAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BaseOperationResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getOperationAsyncStatus().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getOperationAsyncStatus().'
            );
        }

        if (requestParameters['handleId'] == null) {
            throw new runtime.RequiredError(
                'handleId',
                'Required parameter "handleId" was null or undefined when calling getOperationAsyncStatus().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-status/{handleId}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))).replace(`{${"handleId"}}`, encodeURIComponent(String(requestParameters['handleId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the status of an asynchronously invoked Operation
     */
    async getOperationAsyncStatus(requestParameters: GetOperationAsyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BaseOperationResult> {
        const response = await this.getOperationAsyncStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific Submodel
     */
    async getSubmodelByIdRaw(requestParameters: GetSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Submodel>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a specific Submodel
     */
    async getSubmodelById(requestParameters: GetSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Submodel> {
        const response = await this.getSubmodelByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the metadata attributes of a specific Submodel
     */
    async getSubmodelByIdMetadataRaw(requestParameters: GetSubmodelByIdMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelMetadata>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelByIdMetadata().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$metadata`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the metadata attributes of a specific Submodel
     */
    async getSubmodelByIdMetadata(requestParameters: GetSubmodelByIdMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelMetadata> {
        const response = await this.getSubmodelByIdMetadataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific Submodel in the Path notation
     */
    async getSubmodelByIdPathRaw(requestParameters: GetSubmodelByIdPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelByIdPath().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$path`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a specific Submodel in the Path notation
     */
    async getSubmodelByIdPath(requestParameters: GetSubmodelByIdPathRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getSubmodelByIdPathRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Reference of a specific Submodel
     */
    async getSubmodelByIdReferenceRaw(requestParameters: GetSubmodelByIdReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Reference>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelByIdReference().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$reference`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the Reference of a specific Submodel
     */
    async getSubmodelByIdReference(requestParameters: GetSubmodelByIdReferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Reference> {
        const response = await this.getSubmodelByIdReferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific Submodel in the ValueOnly representation
     */
    async getSubmodelByIdValueOnlyRaw(requestParameters: GetSubmodelByIdValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelByIdValueOnly().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a specific Submodel in the ValueOnly representation
     */
    async getSubmodelByIdValueOnly(requestParameters: GetSubmodelByIdValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.getSubmodelByIdValueOnlyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathMetadataSubmodelRepoRaw(requestParameters: GetSubmodelElementByPathMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElementMetadata>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelElementByPathMetadataSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getSubmodelElementByPathMetadataSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathMetadataSubmodelRepo(requestParameters: GetSubmodelElementByPathMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElementMetadata> {
        const response = await this.getSubmodelElementByPathMetadataSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path in the Path notation
     */
    async getSubmodelElementByPathPathSubmodelRepoRaw(requestParameters: GetSubmodelElementByPathPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string>>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelElementByPathPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getSubmodelElementByPathPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$path`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path in the Path notation
     */
    async getSubmodelElementByPathPathSubmodelRepo(requestParameters: GetSubmodelElementByPathPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string>> {
        const response = await this.getSubmodelElementByPathPathSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the Referene of a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathReferenceSubmodelRepoRaw(requestParameters: GetSubmodelElementByPathReferenceSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Reference>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelElementByPathReferenceSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getSubmodelElementByPathReferenceSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$reference`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the Referene of a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathReferenceSubmodelRepo(requestParameters: GetSubmodelElementByPathReferenceSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Reference> {
        const response = await this.getSubmodelElementByPathReferenceSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathSubmodelRepoRaw(requestParameters: GetSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElement>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getSubmodelElementByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path
     */
    async getSubmodelElementByPathSubmodelRepo(requestParameters: GetSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElement> {
        const response = await this.getSubmodelElementByPathSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     */
    async getSubmodelElementByPathValueOnlySubmodelRepoRaw(requestParameters: GetSubmodelElementByPathValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElementValue>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling getSubmodelElementByPathValueOnlySubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling getSubmodelElementByPathValueOnlySubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        if (requestParameters['extent'] != null) {
            queryParameters['extent'] = requestParameters['extent'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     */
    async getSubmodelElementByPathValueOnlySubmodelRepo(requestParameters: GetSubmodelElementByPathValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElementValue> {
        const response = await this.getSubmodelElementByPathValueOnlySubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Asynchronously invokes an Operation at a specified path
     */
    async invokeOperationAsyncRaw(requestParameters: InvokeOperationAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling invokeOperationAsync().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling invokeOperationAsync().'
            );
        }

        if (requestParameters['operationRequest'] == null) {
            throw new runtime.RequiredError(
                'operationRequest',
                'Required parameter "operationRequest" was null or undefined when calling invokeOperationAsync().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['operationRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Asynchronously invokes an Operation at a specified path
     */
    async invokeOperationAsync(requestParameters: InvokeOperationAsyncRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.invokeOperationAsyncRaw(requestParameters, initOverrides);
    }

    /**
     * Asynchronously invokes an Operation at a specified path
     */
    async invokeOperationAsyncValueOnlyRaw(requestParameters: InvokeOperationAsyncValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['aasIdentifier'] == null) {
            throw new runtime.RequiredError(
                'aasIdentifier',
                'Required parameter "aasIdentifier" was null or undefined when calling invokeOperationAsyncValueOnly().'
            );
        }

        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling invokeOperationAsyncValueOnly().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling invokeOperationAsyncValueOnly().'
            );
        }

        if (requestParameters['operationRequestValueOnly'] == null) {
            throw new runtime.RequiredError(
                'operationRequestValueOnly',
                'Required parameter "operationRequestValueOnly" was null or undefined when calling invokeOperationAsyncValueOnly().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async/$value`.replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(requestParameters['aasIdentifier']))).replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['operationRequestValueOnly'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Asynchronously invokes an Operation at a specified path
     */
    async invokeOperationAsyncValueOnly(requestParameters: InvokeOperationAsyncValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.invokeOperationAsyncValueOnlyRaw(requestParameters, initOverrides);
    }

    /**
     * Synchronously invokes an Operation at a specified path
     */
    async invokeOperationSubmodelRepoRaw(requestParameters: InvokeOperationSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResult>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling invokeOperationSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling invokeOperationSubmodelRepo().'
            );
        }

        if (requestParameters['operationRequest'] == null) {
            throw new runtime.RequiredError(
                'operationRequest',
                'Required parameter "operationRequest" was null or undefined when calling invokeOperationSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['operationRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Synchronously invokes an Operation at a specified path
     */
    async invokeOperationSubmodelRepo(requestParameters: InvokeOperationSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResult> {
        const response = await this.invokeOperationSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Synchronously invokes an Operation at a specified path
     */
    async invokeOperationValueOnlyRaw(requestParameters: InvokeOperationValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OperationResultValueOnly>> {
        if (requestParameters['aasIdentifier'] == null) {
            throw new runtime.RequiredError(
                'aasIdentifier',
                'Required parameter "aasIdentifier" was null or undefined when calling invokeOperationValueOnly().'
            );
        }

        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling invokeOperationValueOnly().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling invokeOperationValueOnly().'
            );
        }

        if (requestParameters['operationRequestValueOnly'] == null) {
            throw new runtime.RequiredError(
                'operationRequestValueOnly',
                'Required parameter "operationRequestValueOnly" was null or undefined when calling invokeOperationValueOnly().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke/$value`.replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(requestParameters['aasIdentifier']))).replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['operationRequestValueOnly'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Synchronously invokes an Operation at a specified path
     */
    async invokeOperationValueOnly(requestParameters: InvokeOperationValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OperationResultValueOnly> {
        const response = await this.invokeOperationValueOnlyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates an existing Submodel
     */
    async patchSubmodelByIdRaw(requestParameters: PatchSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelById().'
            );
        }

        if (requestParameters['submodel'] == null) {
            throw new runtime.RequiredError(
                'submodel',
                'Required parameter "submodel" was null or undefined when calling patchSubmodelById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodel'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing Submodel
     */
    async patchSubmodelById(requestParameters: PatchSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the metadata attributes of an existing Submodel
     */
    async patchSubmodelByIdMetadataRaw(requestParameters: PatchSubmodelByIdMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelByIdMetadata().'
            );
        }

        if (requestParameters['submodelMetadata'] == null) {
            throw new runtime.RequiredError(
                'submodelMetadata',
                'Required parameter "submodelMetadata" was null or undefined when calling patchSubmodelByIdMetadata().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$metadata`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelMetadata'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the metadata attributes of an existing Submodel
     */
    async patchSubmodelByIdMetadata(requestParameters: PatchSubmodelByIdMetadataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelByIdMetadataRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the values of an existing Submodel
     */
    async patchSubmodelByIdValueOnlyRaw(requestParameters: PatchSubmodelByIdValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelByIdValueOnly().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling patchSubmodelByIdValueOnly().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the values of an existing Submodel
     */
    async patchSubmodelByIdValueOnly(requestParameters: PatchSubmodelByIdValueOnlyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelByIdValueOnlyRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the metadata attributes an existing SubmodelElement
     */
    async patchSubmodelElementByPathMetadataSubmodelRepoRaw(requestParameters: PatchSubmodelElementByPathMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo().'
            );
        }

        if (requestParameters['submodelElementMetadata'] == null) {
            throw new runtime.RequiredError(
                'submodelElementMetadata',
                'Required parameter "submodelElementMetadata" was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElementMetadata'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the metadata attributes an existing SubmodelElement
     */
    async patchSubmodelElementByPathMetadataSubmodelRepo(requestParameters: PatchSubmodelElementByPathMetadataSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelElementByPathMetadataSubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Updates an existing SubmodelElement
     */
    async patchSubmodelElementByPathSubmodelRepoRaw(requestParameters: PatchSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling patchSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['submodelElement'] == null) {
            throw new runtime.RequiredError(
                'submodelElement',
                'Required parameter "submodelElement" was null or undefined when calling patchSubmodelElementByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElement'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates an existing SubmodelElement
     */
    async patchSubmodelElementByPathSubmodelRepo(requestParameters: PatchSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelElementByPathSubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Updates the value of an existing SubmodelElement
     */
    async patchSubmodelElementByPathValueOnlySubmodelRepoRaw(requestParameters: PatchSubmodelElementByPathValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo().'
            );
        }

        if (requestParameters['submodelElementValue'] == null) {
            throw new runtime.RequiredError(
                'submodelElementValue',
                'Required parameter "submodelElementValue" was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElementValue'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates the value of an existing SubmodelElement
     */
    async patchSubmodelElementByPathValueOnlySubmodelRepo(requestParameters: PatchSubmodelElementByPathValueOnlySubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.patchSubmodelElementByPathValueOnlySubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Creates a new Submodel
     */
    async postSubmodelRaw(requestParameters: PostSubmodelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Submodel>> {
        if (requestParameters['submodel'] == null) {
            throw new runtime.RequiredError(
                'submodel',
                'Required parameter "submodel" was null or undefined when calling postSubmodel().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new Submodel
     */
    async postSubmodel(requestParameters: PostSubmodelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Submodel> {
        const response = await this.postSubmodelRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new submodel element at a specified path within submodel elements hierarchy
     */
    async postSubmodelElementByPathSubmodelRepoRaw(requestParameters: PostSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElement>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling postSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling postSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['submodelElement'] == null) {
            throw new runtime.RequiredError(
                'submodelElement',
                'Required parameter "submodelElement" was null or undefined when calling postSubmodelElementByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElement'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new submodel element at a specified path within submodel elements hierarchy
     */
    async postSubmodelElementByPathSubmodelRepo(requestParameters: PostSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElement> {
        const response = await this.postSubmodelElementByPathSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new submodel element
     */
    async postSubmodelElementSubmodelRepoRaw(requestParameters: PostSubmodelElementSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElement>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling postSubmodelElementSubmodelRepo().'
            );
        }

        if (requestParameters['submodelElement'] == null) {
            throw new runtime.RequiredError(
                'submodelElement',
                'Required parameter "submodelElement" was null or undefined when calling postSubmodelElementSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElement'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a new submodel element
     */
    async postSubmodelElementSubmodelRepo(requestParameters: PostSubmodelElementSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElement> {
        const response = await this.postSubmodelElementSubmodelRepoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     */
    async putFileByPathSubmodelRepoRaw(requestParameters: PutFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling putFileByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling putFileByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['fileName'] != null) {
            formParams.append('fileName', requestParameters['fileName'] as any);
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     */
    async putFileByPathSubmodelRepo(requestParameters: PutFileByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.putFileByPathSubmodelRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Creates or updates an existing Submodel
     */
    async putSubmodelByIdRaw(requestParameters: PutSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Submodel>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling putSubmodelById().'
            );
        }

        if (requestParameters['submodel'] == null) {
            throw new runtime.RequiredError(
                'submodel',
                'Required parameter "submodel" was null or undefined when calling putSubmodelById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates an existing Submodel
     */
    async putSubmodelById(requestParameters: PutSubmodelByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Submodel | null | undefined > {
        const response = await this.putSubmodelByIdRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 201:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Creates or updates an existing submodel element at a specified path within submodel elements hierarchy
     */
    async putSubmodelElementByPathSubmodelRepoRaw(requestParameters: PutSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SubmodelElement>> {
        if (requestParameters['submodelIdentifier'] == null) {
            throw new runtime.RequiredError(
                'submodelIdentifier',
                'Required parameter "submodelIdentifier" was null or undefined when calling putSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['idShortPath'] == null) {
            throw new runtime.RequiredError(
                'idShortPath',
                'Required parameter "idShortPath" was null or undefined when calling putSubmodelElementByPathSubmodelRepo().'
            );
        }

        if (requestParameters['submodelElement'] == null) {
            throw new runtime.RequiredError(
                'submodelElement',
                'Required parameter "submodelElement" was null or undefined when calling putSubmodelElementByPathSubmodelRepo().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['level'] != null) {
            queryParameters['level'] = requestParameters['level'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`.replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(requestParameters['submodelIdentifier']))).replace(`{${"idShortPath"}}`, encodeURIComponent(String(requestParameters['idShortPath']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['submodelElement'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates or updates an existing submodel element at a specified path within submodel elements hierarchy
     */
    async putSubmodelElementByPathSubmodelRepo(requestParameters: PutSubmodelElementByPathSubmodelRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SubmodelElement | null | undefined > {
        const response = await this.putSubmodelElementByPathSubmodelRepoRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 201:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

}

/**
 * @export
 */
export const GetAllSubmodelElementsLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelElementsLevelEnum = typeof GetAllSubmodelElementsLevelEnum[keyof typeof GetAllSubmodelElementsLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelElementsExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetAllSubmodelElementsExtentEnum = typeof GetAllSubmodelElementsExtentEnum[keyof typeof GetAllSubmodelElementsExtentEnum];
/**
 * @export
 */
export const GetAllSubmodelElementsPathSubmodelRepoLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelElementsPathSubmodelRepoLevelEnum = typeof GetAllSubmodelElementsPathSubmodelRepoLevelEnum[keyof typeof GetAllSubmodelElementsPathSubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelElementsReferenceSubmodelRepoLevelEnum = {
    Core: 'core'
} as const;
export type GetAllSubmodelElementsReferenceSubmodelRepoLevelEnum = typeof GetAllSubmodelElementsReferenceSubmodelRepoLevelEnum[keyof typeof GetAllSubmodelElementsReferenceSubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelElementsValueOnlySubmodelRepoLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelElementsValueOnlySubmodelRepoLevelEnum = typeof GetAllSubmodelElementsValueOnlySubmodelRepoLevelEnum[keyof typeof GetAllSubmodelElementsValueOnlySubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelElementsValueOnlySubmodelRepoExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetAllSubmodelElementsValueOnlySubmodelRepoExtentEnum = typeof GetAllSubmodelElementsValueOnlySubmodelRepoExtentEnum[keyof typeof GetAllSubmodelElementsValueOnlySubmodelRepoExtentEnum];
/**
 * @export
 */
export const GetAllSubmodelsLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelsLevelEnum = typeof GetAllSubmodelsLevelEnum[keyof typeof GetAllSubmodelsLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelsExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetAllSubmodelsExtentEnum = typeof GetAllSubmodelsExtentEnum[keyof typeof GetAllSubmodelsExtentEnum];
/**
 * @export
 */
export const GetAllSubmodelsPathLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelsPathLevelEnum = typeof GetAllSubmodelsPathLevelEnum[keyof typeof GetAllSubmodelsPathLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelsReferenceLevelEnum = {
    Core: 'core'
} as const;
export type GetAllSubmodelsReferenceLevelEnum = typeof GetAllSubmodelsReferenceLevelEnum[keyof typeof GetAllSubmodelsReferenceLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelsValueOnlyLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetAllSubmodelsValueOnlyLevelEnum = typeof GetAllSubmodelsValueOnlyLevelEnum[keyof typeof GetAllSubmodelsValueOnlyLevelEnum];
/**
 * @export
 */
export const GetAllSubmodelsValueOnlyExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetAllSubmodelsValueOnlyExtentEnum = typeof GetAllSubmodelsValueOnlyExtentEnum[keyof typeof GetAllSubmodelsValueOnlyExtentEnum];
/**
 * @export
 */
export const GetSubmodelByIdLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelByIdLevelEnum = typeof GetSubmodelByIdLevelEnum[keyof typeof GetSubmodelByIdLevelEnum];
/**
 * @export
 */
export const GetSubmodelByIdExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetSubmodelByIdExtentEnum = typeof GetSubmodelByIdExtentEnum[keyof typeof GetSubmodelByIdExtentEnum];
/**
 * @export
 */
export const GetSubmodelByIdPathLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelByIdPathLevelEnum = typeof GetSubmodelByIdPathLevelEnum[keyof typeof GetSubmodelByIdPathLevelEnum];
/**
 * @export
 */
export const GetSubmodelByIdValueOnlyLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelByIdValueOnlyLevelEnum = typeof GetSubmodelByIdValueOnlyLevelEnum[keyof typeof GetSubmodelByIdValueOnlyLevelEnum];
/**
 * @export
 */
export const GetSubmodelByIdValueOnlyExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetSubmodelByIdValueOnlyExtentEnum = typeof GetSubmodelByIdValueOnlyExtentEnum[keyof typeof GetSubmodelByIdValueOnlyExtentEnum];
/**
 * @export
 */
export const GetSubmodelElementByPathPathSubmodelRepoLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelElementByPathPathSubmodelRepoLevelEnum = typeof GetSubmodelElementByPathPathSubmodelRepoLevelEnum[keyof typeof GetSubmodelElementByPathPathSubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetSubmodelElementByPathSubmodelRepoLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelElementByPathSubmodelRepoLevelEnum = typeof GetSubmodelElementByPathSubmodelRepoLevelEnum[keyof typeof GetSubmodelElementByPathSubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetSubmodelElementByPathSubmodelRepoExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetSubmodelElementByPathSubmodelRepoExtentEnum = typeof GetSubmodelElementByPathSubmodelRepoExtentEnum[keyof typeof GetSubmodelElementByPathSubmodelRepoExtentEnum];
/**
 * @export
 */
export const GetSubmodelElementByPathValueOnlySubmodelRepoLevelEnum = {
    Deep: 'deep',
    Core: 'core'
} as const;
export type GetSubmodelElementByPathValueOnlySubmodelRepoLevelEnum = typeof GetSubmodelElementByPathValueOnlySubmodelRepoLevelEnum[keyof typeof GetSubmodelElementByPathValueOnlySubmodelRepoLevelEnum];
/**
 * @export
 */
export const GetSubmodelElementByPathValueOnlySubmodelRepoExtentEnum = {
    WithBlobValue: 'withBlobValue',
    WithoutBlobValue: 'withoutBlobValue'
} as const;
export type GetSubmodelElementByPathValueOnlySubmodelRepoExtentEnum = typeof GetSubmodelElementByPathValueOnlySubmodelRepoExtentEnum[keyof typeof GetSubmodelElementByPathValueOnlySubmodelRepoExtentEnum];
/**
 * @export
 */
export const PatchSubmodelByIdLevelEnum = {
    Core: 'core'
} as const;
export type PatchSubmodelByIdLevelEnum = typeof PatchSubmodelByIdLevelEnum[keyof typeof PatchSubmodelByIdLevelEnum];
/**
 * @export
 */
export const PatchSubmodelByIdMetadataLevelEnum = {
    Core: 'core'
} as const;
export type PatchSubmodelByIdMetadataLevelEnum = typeof PatchSubmodelByIdMetadataLevelEnum[keyof typeof PatchSubmodelByIdMetadataLevelEnum];
/**
 * @export
 */
export const PatchSubmodelByIdValueOnlyLevelEnum = {
    Core: 'core'
} as const;
export type PatchSubmodelByIdValueOnlyLevelEnum = typeof PatchSubmodelByIdValueOnlyLevelEnum[keyof typeof PatchSubmodelByIdValueOnlyLevelEnum];
/**
 * @export
 */
export const PatchSubmodelElementByPathSubmodelRepoLevelEnum = {
    Core: 'core'
} as const;
export type PatchSubmodelElementByPathSubmodelRepoLevelEnum = typeof PatchSubmodelElementByPathSubmodelRepoLevelEnum[keyof typeof PatchSubmodelElementByPathSubmodelRepoLevelEnum];
/**
 * @export
 */
export const PatchSubmodelElementByPathValueOnlySubmodelRepoLevelEnum = {
    Core: 'core'
} as const;
export type PatchSubmodelElementByPathValueOnlySubmodelRepoLevelEnum = typeof PatchSubmodelElementByPathValueOnlySubmodelRepoLevelEnum[keyof typeof PatchSubmodelElementByPathValueOnlySubmodelRepoLevelEnum];
/**
 * @export
 */
export const PutSubmodelElementByPathSubmodelRepoLevelEnum = {
    Deep: 'deep'
} as const;
export type PutSubmodelElementByPathSubmodelRepoLevelEnum = typeof PutSubmodelElementByPathSubmodelRepoLevelEnum[keyof typeof PutSubmodelElementByPathSubmodelRepoLevelEnum];
