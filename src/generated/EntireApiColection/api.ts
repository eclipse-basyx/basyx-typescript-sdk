/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * DotAAS Part 2 | HTTP/REST | Entire API Collection
 * All APIs of the Specification of the [Specification of the Asset Administration Shell: Part 2](http://industrialdigitaltwin.org/en/content-hub) in one collection. Please not that this API is not intended to generate productive code but only for overview purposes.   Publisher: Industrial Digital Twin Association (IDTA) 2023\"
 *
 * OpenAPI spec version: V3.0.1
 * Contact: info@idtwin.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "{protocol}://{host_name}:{port}/api/{version_prefix}".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        this.configuration = configuration;
        this.basePath = configuration.basePath || this.basePath;
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum AasSubmodelElements {
    AnnotatedRelationshipElement = <any> 'AnnotatedRelationshipElement',
    BasicEventElement = <any> 'BasicEventElement',
    Blob = <any> 'Blob',
    Capability = <any> 'Capability',
    DataElement = <any> 'DataElement',
    Entity = <any> 'Entity',
    EventElement = <any> 'EventElement',
    File = <any> 'File',
    MultiLanguageProperty = <any> 'MultiLanguageProperty',
    Operation = <any> 'Operation',
    Property = <any> 'Property',
    Range = <any> 'Range',
    ReferenceElement = <any> 'ReferenceElement',
    RelationshipElement = <any> 'RelationshipElement',
    SubmodelElement = <any> 'SubmodelElement',
    SubmodelElementCollection = <any> 'SubmodelElementCollection',
    SubmodelElementList = <any> 'SubmodelElementList'
}
/**
 * 
 * @export
 * @interface AbstractLangString
 */
export interface AbstractLangString {
    /**
     * 
     * @type {string}
     * @memberof AbstractLangString
     */
    language: string;
    /**
     * 
     * @type {string}
     * @memberof AbstractLangString
     */
    text: string;
}
/**
 * 
 * @export
 * @interface AdministrativeInformation
 */
export interface AdministrativeInformation extends HasDataSpecification {
    /**
     * 
     * @type {any}
     * @memberof AdministrativeInformation
     */
    version?: any;
    /**
     * 
     * @type {any}
     * @memberof AdministrativeInformation
     */
    revision?: any;
    /**
     * 
     * @type {Reference}
     * @memberof AdministrativeInformation
     */
    creator?: Reference;
    /**
     * 
     * @type {string}
     * @memberof AdministrativeInformation
     */
    templateId?: string;
}
/**
 * 
 * @export
 * @interface AnnotatedRelationshipElement
 */
export interface AnnotatedRelationshipElement extends RelationshipElementAbstract {
    /**
     * 
     * @type {Array<DataElementChoice>}
     * @memberof AnnotatedRelationshipElement
     */
    annotations?: Array<DataElementChoice>;
    /**
     * 
     * @type {string}
     * @memberof AnnotatedRelationshipElement
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface AnnotatedRelationshipElementMetadata
 */
export interface AnnotatedRelationshipElementMetadata extends Referable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Reference}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    modelType: ModelType;
    /**
     * 
     * @type {ModellingKind}
     * @memberof AnnotatedRelationshipElementMetadata
     */
    kind?: ModellingKind;
}
/**
 * 
 * @export
 * @interface AnnotatedRelationshipElementValue
 */
export interface AnnotatedRelationshipElementValue {
    /**
     * 
     * @type {ReferenceValue}
     * @memberof AnnotatedRelationshipElementValue
     */
    first: ReferenceValue;
    /**
     * 
     * @type {ReferenceValue}
     * @memberof AnnotatedRelationshipElementValue
     */
    second: ReferenceValue;
    /**
     * 
     * @type {Array<ValueOnly>}
     * @memberof AnnotatedRelationshipElementValue
     */
    annotations?: Array<ValueOnly>;
}
/**
 * 
 * @export
 * @interface AssetAdministrationShell
 */
export interface AssetAdministrationShell extends Identifiable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof AssetAdministrationShell
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Reference}
     * @memberof AssetAdministrationShell
     */
    derivedFrom?: Reference;
    /**
     * 
     * @type {AssetInformation}
     * @memberof AssetAdministrationShell
     */
    assetInformation: AssetInformation;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof AssetAdministrationShell
     */
    submodels?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof AssetAdministrationShell
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface AssetAdministrationShellDescriptor
 */
export interface AssetAdministrationShellDescriptor extends Descriptor {
    /**
     * 
     * @type {AdministrativeInformation}
     * @memberof AssetAdministrationShellDescriptor
     */
    administration?: AdministrativeInformation;
    /**
     * 
     * @type {AssetKind}
     * @memberof AssetAdministrationShellDescriptor
     */
    assetKind?: AssetKind;
    /**
     * 
     * @type {string}
     * @memberof AssetAdministrationShellDescriptor
     */
    assetType?: string;
    /**
     * 
     * @type {Array<Endpoint>}
     * @memberof AssetAdministrationShellDescriptor
     */
    endpoints?: Array<Endpoint>;
    /**
     * 
     * @type {string}
     * @memberof AssetAdministrationShellDescriptor
     */
    globalAssetId?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetAdministrationShellDescriptor
     */
    idShort?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetAdministrationShellDescriptor
     */
    id: string;
    /**
     * 
     * @type {Array<SpecificAssetId>}
     * @memberof AssetAdministrationShellDescriptor
     */
    specificAssetIds?: Array<SpecificAssetId>;
    /**
     * 
     * @type {Array<SubmodelDescriptor>}
     * @memberof AssetAdministrationShellDescriptor
     */
    submodelDescriptors?: Array<SubmodelDescriptor>;
}
/**
 * 
 * @export
 * @interface AssetInformation
 */
export interface AssetInformation {
    /**
     * 
     * @type {AssetKind}
     * @memberof AssetInformation
     */
    assetKind: AssetKind;
    /**
     * 
     * @type {string}
     * @memberof AssetInformation
     */
    globalAssetId?: string;
    /**
     * 
     * @type {Array<SpecificAssetId>}
     * @memberof AssetInformation
     */
    specificAssetIds?: Array<SpecificAssetId>;
    /**
     * 
     * @type {string}
     * @memberof AssetInformation
     */
    assetType?: string;
    /**
     * 
     * @type {Resource}
     * @memberof AssetInformation
     */
    defaultThumbnail?: Resource;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AssetKind {
    Instance = <any> 'Instance',
    NotApplicable = <any> 'NotApplicable',
    Type = <any> 'Type'
}
/**
 * 
 * @export
 * @interface AssetinformationThumbnailBody
 */
export interface AssetinformationThumbnailBody {
    /**
     * 
     * @type {string}
     * @memberof AssetinformationThumbnailBody
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof AssetinformationThumbnailBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface AssetinformationThumbnailBody1
 */
export interface AssetinformationThumbnailBody1 {
    /**
     * 
     * @type {string}
     * @memberof AssetinformationThumbnailBody1
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof AssetinformationThumbnailBody1
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface BaseOperationResult
 */
export interface BaseOperationResult extends Result {
    /**
     * 
     * @type {ExecutionState}
     * @memberof BaseOperationResult
     */
    executionState?: ExecutionState;
    /**
     * 
     * @type {boolean}
     * @memberof BaseOperationResult
     */
    success?: boolean;
}
/**
 * 
 * @export
 * @interface BasicEventElement
 */
export interface BasicEventElement extends EventElement {
    /**
     * 
     * @type {Reference}
     * @memberof BasicEventElement
     */
    observed: Reference;
    /**
     * 
     * @type {Direction}
     * @memberof BasicEventElement
     */
    direction: Direction;
    /**
     * 
     * @type {StateOfEvent}
     * @memberof BasicEventElement
     */
    state: StateOfEvent;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElement
     */
    messageTopic?: string;
    /**
     * 
     * @type {Reference}
     * @memberof BasicEventElement
     */
    messageBroker?: Reference;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElement
     */
    lastUpdate?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElement
     */
    minInterval?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElement
     */
    maxInterval?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElement
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface BasicEventElementMetadata
 */
export interface BasicEventElementMetadata extends SubmodelElementAttributes {
    /**
     * 
     * @type {Direction}
     * @memberof BasicEventElementMetadata
     */
    direction?: Direction;
    /**
     * 
     * @type {StateOfEvent}
     * @memberof BasicEventElementMetadata
     */
    state?: StateOfEvent;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElementMetadata
     */
    messageTopic?: string;
    /**
     * 
     * @type {Reference}
     * @memberof BasicEventElementMetadata
     */
    messageBroker?: Reference;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElementMetadata
     */
    lastUpdate?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElementMetadata
     */
    minInterval?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicEventElementMetadata
     */
    maxInterval?: string;
}
/**
 * 
 * @export
 * @interface BasicEventElementValue
 */
export interface BasicEventElementValue {
    /**
     * 
     * @type {ReferenceValue}
     * @memberof BasicEventElementValue
     */
    observed: ReferenceValue;
}
/**
 * 
 * @export
 * @interface Blob
 */
export interface Blob extends DataElement {
    /**
     * 
     * @type {string}
     * @memberof Blob
     */
    value?: string;
    /**
     * 
     * @type {any}
     * @memberof Blob
     */
    contentType: any;
    /**
     * 
     * @type {string}
     * @memberof Blob
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface BlobMetadata
 */
export interface BlobMetadata extends Referable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof BlobMetadata
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Reference}
     * @memberof BlobMetadata
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof BlobMetadata
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof BlobMetadata
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof BlobMetadata
     */
    modelType: ModelType;
    /**
     * 
     * @type {ModellingKind}
     * @memberof BlobMetadata
     */
    kind?: ModellingKind;
}
/**
 * 
 * @export
 * @interface BlobValue
 */
export interface BlobValue {
    /**
     * 
     * @type {string}
     * @memberof BlobValue
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof BlobValue
     */
    value: string;
}
/**
 * 
 * @export
 */
export type BooleanValue = boolean
/**
 * 
 * @export
 * @interface Capability
 */
export interface Capability extends SubmodelElement {
    /**
     * 
     * @type {string}
     * @memberof Capability
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface CapabilityMetadata
 */
export interface CapabilityMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface ConceptDescription
 */
export interface ConceptDescription extends Identifiable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof ConceptDescription
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof ConceptDescription
     */
    isCaseOf?: Array<Reference>;
    /**
     * 
     * @type {string}
     * @memberof ConceptDescription
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface DataElement
 */
export interface DataElement extends SubmodelElement {
}
/**
 * 
 * @export
 * @interface DataElementChoice
 */
export interface DataElementChoice {
}
/**
 * 
 * @export
 * @interface DataSpecificationContent
 */
export interface DataSpecificationContent {
    /**
     * 
     * @type {ModelType}
     * @memberof DataSpecificationContent
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface DataSpecificationContentChoice
 */
export interface DataSpecificationContentChoice {
}
/**
 * 
 * @export
 * @interface DataSpecificationIec61360
 */
export interface DataSpecificationIec61360 extends DataSpecificationContent {
    /**
     * 
     * @type {Array<LangStringPreferredNameTypeIec61360>}
     * @memberof DataSpecificationIec61360
     */
    preferredName: Array<LangStringPreferredNameTypeIec61360>;
    /**
     * 
     * @type {Array<LangStringShortNameTypeIec61360>}
     * @memberof DataSpecificationIec61360
     */
    shortName?: Array<LangStringShortNameTypeIec61360>;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    unit?: string;
    /**
     * 
     * @type {Reference}
     * @memberof DataSpecificationIec61360
     */
    unitId?: Reference;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    sourceOfDefinition?: string;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    symbol?: string;
    /**
     * 
     * @type {DataTypeIec61360}
     * @memberof DataSpecificationIec61360
     */
    dataType?: DataTypeIec61360;
    /**
     * 
     * @type {Array<LangStringDefinitionTypeIec61360>}
     * @memberof DataSpecificationIec61360
     */
    definition?: Array<LangStringDefinitionTypeIec61360>;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    valueFormat?: string;
    /**
     * 
     * @type {ValueList}
     * @memberof DataSpecificationIec61360
     */
    valueList?: ValueList;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    value?: string;
    /**
     * 
     * @type {LevelType}
     * @memberof DataSpecificationIec61360
     */
    levelType?: LevelType;
    /**
     * 
     * @type {string}
     * @memberof DataSpecificationIec61360
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DataTypeDefXsd {
    AnyURI = <any> 'xs:anyURI',
    Base64Binary = <any> 'xs:base64Binary',
    Boolean = <any> 'xs:boolean',
    Byte = <any> 'xs:byte',
    Date = <any> 'xs:date',
    DateTime = <any> 'xs:dateTime',
    Decimal = <any> 'xs:decimal',
    Double = <any> 'xs:double',
    Duration = <any> 'xs:duration',
    Float = <any> 'xs:float',
    GDay = <any> 'xs:gDay',
    GMonth = <any> 'xs:gMonth',
    GMonthDay = <any> 'xs:gMonthDay',
    GYear = <any> 'xs:gYear',
    GYearMonth = <any> 'xs:gYearMonth',
    HexBinary = <any> 'xs:hexBinary',
    Int = <any> 'xs:int',
    Integer = <any> 'xs:integer',
    Long = <any> 'xs:long',
    NegativeInteger = <any> 'xs:negativeInteger',
    NonNegativeInteger = <any> 'xs:nonNegativeInteger',
    NonPositiveInteger = <any> 'xs:nonPositiveInteger',
    PositiveInteger = <any> 'xs:positiveInteger',
    Short = <any> 'xs:short',
    String = <any> 'xs:string',
    Time = <any> 'xs:time',
    UnsignedByte = <any> 'xs:unsignedByte',
    UnsignedInt = <any> 'xs:unsignedInt',
    UnsignedLong = <any> 'xs:unsignedLong',
    UnsignedShort = <any> 'xs:unsignedShort'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DataTypeIec61360 {
    BLOB = <any> 'BLOB',
    BOOLEAN = <any> 'BOOLEAN',
    DATE = <any> 'DATE',
    FILE = <any> 'FILE',
    HTML = <any> 'HTML',
    INTEGERCOUNT = <any> 'INTEGER_COUNT',
    INTEGERCURRENCY = <any> 'INTEGER_CURRENCY',
    INTEGERMEASURE = <any> 'INTEGER_MEASURE',
    IRDI = <any> 'IRDI',
    IRI = <any> 'IRI',
    RATIONAL = <any> 'RATIONAL',
    RATIONALMEASURE = <any> 'RATIONAL_MEASURE',
    REALCOUNT = <any> 'REAL_COUNT',
    REALCURRENCY = <any> 'REAL_CURRENCY',
    REALMEASURE = <any> 'REAL_MEASURE',
    STRING = <any> 'STRING',
    STRINGTRANSLATABLE = <any> 'STRING_TRANSLATABLE',
    TIME = <any> 'TIME',
    TIMESTAMP = <any> 'TIMESTAMP'
}
/**
 * 
 * @export
 * @interface Descriptor
 */
export interface Descriptor {
    /**
     * 
     * @type {Array<LangStringTextType>}
     * @memberof Descriptor
     */
    description?: Array<LangStringTextType>;
    /**
     * 
     * @type {Array<LangStringNameType>}
     * @memberof Descriptor
     */
    displayName?: Array<LangStringNameType>;
    /**
     * 
     * @type {Array<Extension>}
     * @memberof Descriptor
     */
    extensions?: Array<Extension>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Direction {
    Input = <any> 'input',
    Output = <any> 'output'
}
/**
 * 
 * @export
 * @interface EmbeddedDataSpecification
 */
export interface EmbeddedDataSpecification {
    /**
     * 
     * @type {Reference}
     * @memberof EmbeddedDataSpecification
     */
    dataSpecification: Reference;
    /**
     * 
     * @type {DataSpecificationContentChoice}
     * @memberof EmbeddedDataSpecification
     */
    dataSpecificationContent: DataSpecificationContentChoice;
}
/**
 * 
 * @export
 * @interface Endpoint
 */
export interface Endpoint {
    /**
     * 
     * @type {string}
     * @memberof Endpoint
     */
    _interface: string;
    /**
     * 
     * @type {ProtocolInformation}
     * @memberof Endpoint
     */
    protocolInformation: ProtocolInformation;
}
/**
 * 
 * @export
 * @interface Entity
 */
export interface Entity extends SubmodelElement {
    /**
     * 
     * @type {Array<SubmodelElementChoice>}
     * @memberof Entity
     */
    statements?: Array<SubmodelElementChoice>;
    /**
     * 
     * @type {EntityType}
     * @memberof Entity
     */
    entityType: EntityType;
    /**
     * 
     * @type {string}
     * @memberof Entity
     */
    globalAssetId?: string;
    /**
     * 
     * @type {Array<SpecificAssetId>}
     * @memberof Entity
     */
    specificAssetIds?: Array<SpecificAssetId>;
    /**
     * 
     * @type {ModelType}
     * @memberof Entity
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface EntityMetadata
 */
export interface EntityMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EntityType {
    CoManagedEntity = <any> 'CoManagedEntity',
    SelfManagedEntity = <any> 'SelfManagedEntity'
}
/**
 * 
 * @export
 * @interface EntityValue
 */
export interface EntityValue {
    /**
     * 
     * @type {EntityType}
     * @memberof EntityValue
     */
    entityType: EntityType;
    /**
     * 
     * @type {string}
     * @memberof EntityValue
     */
    globalAssetId?: string;
    /**
     * 
     * @type {Array<SpecificAssetIdValue>}
     * @memberof EntityValue
     */
    specificAssetIds?: Array<SpecificAssetIdValue>;
    /**
     * 
     * @type {Array<ValueOnly>}
     * @memberof EntityValue
     */
    statements: Array<ValueOnly>;
}
/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {Array<AssetAdministrationShell>}
     * @memberof Environment
     */
    assetAdministrationShells?: Array<AssetAdministrationShell>;
    /**
     * 
     * @type {Array<Submodel>}
     * @memberof Environment
     */
    submodels?: Array<Submodel>;
    /**
     * 
     * @type {Array<ConceptDescription>}
     * @memberof Environment
     */
    conceptDescriptions?: Array<ConceptDescription>;
}
/**
 * 
 * @export
 * @interface EventElement
 */
export interface EventElement extends SubmodelElement {
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ExecutionState {
    Initiated = <any> 'Initiated',
    Running = <any> 'Running',
    Completed = <any> 'Completed',
    Canceled = <any> 'Canceled',
    Failed = <any> 'Failed',
    Timeout = <any> 'Timeout'
}
/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension extends HasSemantics {
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    name: string;
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof Extension
     */
    valueType?: DataTypeDefXsd;
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    value?: string;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof Extension
     */
    refersTo?: Array<Reference>;
}
/**
 * 
 * @export
 * @interface FileMetadata
 */
export interface FileMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface FileValue
 */
export interface FileValue {
    /**
     * 
     * @type {string}
     * @memberof FileValue
     */
    contentType: string;
    /**
     * 
     * @type {string}
     * @memberof FileValue
     */
    value: string;
}
/**
 * 
 * @export
 * @interface GetAssetAdministrationShellDescriptorsResult
 */
export interface GetAssetAdministrationShellDescriptorsResult extends PagedResult {
    /**
     * 
     * @type {Array<AssetAdministrationShellDescriptor>}
     * @memberof GetAssetAdministrationShellDescriptorsResult
     */
    result?: Array<AssetAdministrationShellDescriptor>;
}
/**
 * 
 * @export
 * @interface GetAssetAdministrationShellsResult
 */
export interface GetAssetAdministrationShellsResult extends PagedResult {
    /**
     * 
     * @type {Array<AssetAdministrationShell>}
     * @memberof GetAssetAdministrationShellsResult
     */
    result?: Array<AssetAdministrationShell>;
}
/**
 * 
 * @export
 * @interface GetConceptDescriptionsResult
 */
export interface GetConceptDescriptionsResult extends PagedResult {
    /**
     * 
     * @type {Array<ConceptDescription>}
     * @memberof GetConceptDescriptionsResult
     */
    result?: Array<ConceptDescription>;
}
/**
 * 
 * @export
 * @interface GetPackageDescriptionsResult
 */
export interface GetPackageDescriptionsResult extends PagedResult {
    /**
     * 
     * @type {Array<PackageDescription>}
     * @memberof GetPackageDescriptionsResult
     */
    result?: Array<PackageDescription>;
}
/**
 * 
 * @export
 * @interface GetPathItemsResult
 */
export interface GetPathItemsResult extends PagedResult {
    /**
     * 
     * @type {Array<PathItem>}
     * @memberof GetPathItemsResult
     */
    result?: Array<PathItem>;
}
/**
 * 
 * @export
 * @interface GetReferencesResult
 */
export interface GetReferencesResult extends PagedResult {
    /**
     * 
     * @type {Array<Reference>}
     * @memberof GetReferencesResult
     */
    result?: Array<Reference>;
}
/**
 * 
 * @export
 * @interface GetSubmodelDescriptorsResult
 */
export interface GetSubmodelDescriptorsResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelDescriptor>}
     * @memberof GetSubmodelDescriptorsResult
     */
    result?: Array<SubmodelDescriptor>;
}
/**
 * 
 * @export
 * @interface GetSubmodelElementsMetadataResult
 */
export interface GetSubmodelElementsMetadataResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelElementMetadata>}
     * @memberof GetSubmodelElementsMetadataResult
     */
    result?: Array<SubmodelElementMetadata>;
}
/**
 * 
 * @export
 * @interface GetSubmodelElementsResult
 */
export interface GetSubmodelElementsResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelElement>}
     * @memberof GetSubmodelElementsResult
     */
    result?: Array<SubmodelElement>;
}
/**
 * 
 * @export
 * @interface GetSubmodelElementsValueResult
 */
export interface GetSubmodelElementsValueResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelElementValue>}
     * @memberof GetSubmodelElementsValueResult
     */
    result?: Array<SubmodelElementValue>;
}
/**
 * 
 * @export
 * @interface GetSubmodelsMetadataResult
 */
export interface GetSubmodelsMetadataResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelMetadata>}
     * @memberof GetSubmodelsMetadataResult
     */
    result?: Array<SubmodelMetadata>;
}
/**
 * 
 * @export
 * @interface GetSubmodelsResult
 */
export interface GetSubmodelsResult extends PagedResult {
    /**
     * 
     * @type {Array<Submodel>}
     * @memberof GetSubmodelsResult
     */
    result?: Array<Submodel>;
}
/**
 * 
 * @export
 * @interface GetSubmodelsValueResult
 */
export interface GetSubmodelsValueResult extends PagedResult {
    /**
     * 
     * @type {Array<SubmodelValue>}
     * @memberof GetSubmodelsValueResult
     */
    result?: Array<SubmodelValue>;
}
/**
 * 
 * @export
 * @interface HasDataSpecification
 */
export interface HasDataSpecification {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof HasDataSpecification
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
}
/**
 * 
 * @export
 * @interface HasExtensions
 */
export interface HasExtensions {
    /**
     * 
     * @type {Array<Extension>}
     * @memberof HasExtensions
     */
    extensions?: Array<Extension>;
}
/**
 * 
 * @export
 * @interface HasKind
 */
export interface HasKind {
    /**
     * 
     * @type {ModellingKind}
     * @memberof HasKind
     */
    kind?: ModellingKind;
}
/**
 * 
 * @export
 * @interface HasSemantics
 */
export interface HasSemantics {
    /**
     * 
     * @type {Reference}
     * @memberof HasSemantics
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof HasSemantics
     */
    supplementalSemanticIds?: Array<Reference>;
}
/**
 * 
 * @export
 * @interface IdShortPathAttachmentBody
 */
export interface IdShortPathAttachmentBody {
    /**
     * 
     * @type {string}
     * @memberof IdShortPathAttachmentBody
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof IdShortPathAttachmentBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface IdShortPathAttachmentBody1
 */
export interface IdShortPathAttachmentBody1 {
    /**
     * 
     * @type {string}
     * @memberof IdShortPathAttachmentBody1
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof IdShortPathAttachmentBody1
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface IdShortPathAttachmentBody2
 */
export interface IdShortPathAttachmentBody2 {
    /**
     * 
     * @type {string}
     * @memberof IdShortPathAttachmentBody2
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof IdShortPathAttachmentBody2
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface IdShortPathAttachmentBody3
 */
export interface IdShortPathAttachmentBody3 {
    /**
     * 
     * @type {string}
     * @memberof IdShortPathAttachmentBody3
     */
    fileName?: string;
    /**
     * 
     * @type {Blob}
     * @memberof IdShortPathAttachmentBody3
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface Identifiable
 */
export interface Identifiable extends Referable {
    /**
     * 
     * @type {AdministrativeInformation}
     * @memberof Identifiable
     */
    administration?: AdministrativeInformation;
    /**
     * 
     * @type {string}
     * @memberof Identifiable
     */
    id: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 extends PagedResult {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse200
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface Key
 */
export interface Key {
    /**
     * 
     * @type {KeyTypes}
     * @memberof Key
     */
    type: KeyTypes;
    /**
     * 
     * @type {string}
     * @memberof Key
     */
    value: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum KeyTypes {
    AnnotatedRelationshipElement = <any> 'AnnotatedRelationshipElement',
    AssetAdministrationShell = <any> 'AssetAdministrationShell',
    BasicEventElement = <any> 'BasicEventElement',
    Blob = <any> 'Blob',
    Capability = <any> 'Capability',
    ConceptDescription = <any> 'ConceptDescription',
    DataElement = <any> 'DataElement',
    Entity = <any> 'Entity',
    EventElement = <any> 'EventElement',
    File = <any> 'File',
    FragmentReference = <any> 'FragmentReference',
    GlobalReference = <any> 'GlobalReference',
    Identifiable = <any> 'Identifiable',
    MultiLanguageProperty = <any> 'MultiLanguageProperty',
    Operation = <any> 'Operation',
    Property = <any> 'Property',
    Range = <any> 'Range',
    Referable = <any> 'Referable',
    ReferenceElement = <any> 'ReferenceElement',
    RelationshipElement = <any> 'RelationshipElement',
    Submodel = <any> 'Submodel',
    SubmodelElement = <any> 'SubmodelElement',
    SubmodelElementCollection = <any> 'SubmodelElementCollection',
    SubmodelElementList = <any> 'SubmodelElementList'
}
/**
 * 
 * @export
 * @interface LangStringDefinitionTypeIec61360
 */
export interface LangStringDefinitionTypeIec61360 extends AbstractLangString {
    /**
     * 
     * @type {any}
     * @memberof LangStringDefinitionTypeIec61360
     */
    text: any;
}
/**
 * 
 * @export
 * @interface LangStringNameType
 */
export interface LangStringNameType extends AbstractLangString {
    /**
     * 
     * @type {any}
     * @memberof LangStringNameType
     */
    text: any;
}
/**
 * 
 * @export
 * @interface LangStringPreferredNameTypeIec61360
 */
export interface LangStringPreferredNameTypeIec61360 extends AbstractLangString {
    /**
     * 
     * @type {any}
     * @memberof LangStringPreferredNameTypeIec61360
     */
    text: any;
}
/**
 * 
 * @export
 * @interface LangStringShortNameTypeIec61360
 */
export interface LangStringShortNameTypeIec61360 extends AbstractLangString {
    /**
     * 
     * @type {any}
     * @memberof LangStringShortNameTypeIec61360
     */
    text: any;
}
/**
 * 
 * @export
 * @interface LangStringTextType
 */
export interface LangStringTextType extends AbstractLangString {
    /**
     * 
     * @type {any}
     * @memberof LangStringTextType
     */
    text: any;
}
/**
 * 
 * @export
 * @interface LevelType
 */
export interface LevelType {
    /**
     * 
     * @type {boolean}
     * @memberof LevelType
     */
    min: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LevelType
     */
    nom: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LevelType
     */
    typ: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LevelType
     */
    max: boolean;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    correlationId?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    messageType?: Message.MessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    text?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    timestamp?: string;
}

/**
 * @export
 * @namespace Message
 */
export namespace Message {
    /**
     * @export
     * @enum {string}
     */
    export enum MessageTypeEnum {
        Undefined = <any> 'Undefined',
        Info = <any> 'Info',
        Warning = <any> 'Warning',
        Error = <any> 'Error',
        Exception = <any> 'Exception'
    }
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile extends DataElement {
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    value?: any;
    /**
     * 
     * @type {any}
     * @memberof ModelFile
     */
    contentType: any;
    /**
     * 
     * @type {ModelType}
     * @memberof ModelFile
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModelType {
    AnnotatedRelationshipElement = <any> 'AnnotatedRelationshipElement',
    AssetAdministrationShell = <any> 'AssetAdministrationShell',
    BasicEventElement = <any> 'BasicEventElement',
    Blob = <any> 'Blob',
    Capability = <any> 'Capability',
    ConceptDescription = <any> 'ConceptDescription',
    DataSpecificationIec61360 = <any> 'DataSpecificationIec61360',
    Entity = <any> 'Entity',
    File = <any> 'File',
    MultiLanguageProperty = <any> 'MultiLanguageProperty',
    Operation = <any> 'Operation',
    Property = <any> 'Property',
    Range = <any> 'Range',
    ReferenceElement = <any> 'ReferenceElement',
    RelationshipElement = <any> 'RelationshipElement',
    Submodel = <any> 'Submodel',
    SubmodelElementCollection = <any> 'SubmodelElementCollection',
    SubmodelElementList = <any> 'SubmodelElementList'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ModellingKind {
    Instance = <any> 'Instance',
    Template = <any> 'Template'
}
/**
 * 
 * @export
 * @interface MultiLanguageProperty
 */
export interface MultiLanguageProperty extends DataElement {
    /**
     * 
     * @type {Array<LangStringTextType>}
     * @memberof MultiLanguageProperty
     */
    value?: Array<LangStringTextType>;
    /**
     * 
     * @type {Reference}
     * @memberof MultiLanguageProperty
     */
    valueId?: Reference;
    /**
     * 
     * @type {string}
     * @memberof MultiLanguageProperty
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface MultiLanguagePropertyMetadata
 */
export interface MultiLanguagePropertyMetadata extends SubmodelElementAttributes {
}
/**
 * Since patternProperties and propertyNames are not supported by OpenApi yet, the ValueOnly serialization for this elements works with the key-attribute as the JSON-property name and the value-attribute as the corresponding value.
 * @export
 * @interface MultiLanguagePropertyValue
 */
export interface MultiLanguagePropertyValue {
}
/**
 * 
 * @export
 */
export type NumberValue = number
/**
 * 
 * @export
 * @interface Operation
 */
export interface Operation extends SubmodelElement {
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof Operation
     */
    inputVariables?: Array<OperationVariable>;
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof Operation
     */
    outputVariables?: Array<OperationVariable>;
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof Operation
     */
    inoutputVariables?: Array<OperationVariable>;
    /**
     * 
     * @type {string}
     * @memberof Operation
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface OperationMetadata
 */
export interface OperationMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface OperationRequest
 */
export interface OperationRequest {
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof OperationRequest
     */
    inoutputArguments?: Array<OperationVariable>;
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof OperationRequest
     */
    inputArguments?: Array<OperationVariable>;
    /**
     * 
     * @type {string}
     * @memberof OperationRequest
     */
    clientTimeoutDuration?: string;
}
/**
 * 
 * @export
 * @interface OperationRequestValueOnly
 */
export interface OperationRequestValueOnly {
    /**
     * 
     * @type {ValueOnly}
     * @memberof OperationRequestValueOnly
     */
    inoutputArguments?: ValueOnly;
    /**
     * 
     * @type {ValueOnly}
     * @memberof OperationRequestValueOnly
     */
    inputArguments?: ValueOnly;
    /**
     * 
     * @type {string}
     * @memberof OperationRequestValueOnly
     */
    clientTimeoutDuration: string;
}
/**
 * 
 * @export
 * @interface OperationResult
 */
export interface OperationResult extends BaseOperationResult {
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof OperationResult
     */
    inoutputArguments?: Array<OperationVariable>;
    /**
     * 
     * @type {Array<OperationVariable>}
     * @memberof OperationResult
     */
    outputArguments?: Array<OperationVariable>;
}
/**
 * 
 * @export
 * @interface OperationResultValueOnly
 */
export interface OperationResultValueOnly extends BaseOperationResult {
    /**
     * 
     * @type {ValueOnly}
     * @memberof OperationResultValueOnly
     */
    inoutputArguments?: ValueOnly;
    /**
     * 
     * @type {ValueOnly}
     * @memberof OperationResultValueOnly
     */
    outputArguments?: ValueOnly;
}
/**
 * 
 * @export
 * @interface OperationVariable
 */
export interface OperationVariable {
    /**
     * 
     * @type {SubmodelElementChoice}
     * @memberof OperationVariable
     */
    value: SubmodelElementChoice;
}
/**
 * 
 * @export
 * @interface PackageDescription
 */
export interface PackageDescription {
    /**
     * 
     * @type {Array<string>}
     * @memberof PackageDescription
     */
    aasIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PackageDescription
     */
    packageId?: string;
}
/**
 * 
 * @export
 * @interface PackagesBody
 */
export interface PackagesBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof PackagesBody
     */
    aasIds?: Array<string>;
    /**
     * 
     * @type {Blob}
     * @memberof PackagesBody
     */
    file?: Blob;
    /**
     * 
     * @type {string}
     * @memberof PackagesBody
     */
    fileName?: string;
}
/**
 * 
 * @export
 * @interface PackagesPackageIdBody
 */
export interface PackagesPackageIdBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof PackagesPackageIdBody
     */
    aasIds?: Array<string>;
    /**
     * 
     * @type {Blob}
     * @memberof PackagesPackageIdBody
     */
    file?: Blob;
    /**
     * 
     * @type {string}
     * @memberof PackagesPackageIdBody
     */
    fileName?: string;
}
/**
 * 
 * @export
 * @interface PagedResult
 */
export interface PagedResult {
    /**
     * 
     * @type {PagedResultPagingMetadata}
     * @memberof PagedResult
     */
    pagingMetadata?: PagedResultPagingMetadata;
}
/**
 * 
 * @export
 * @interface PagedResultPagingMetadata
 */
export interface PagedResultPagingMetadata {
    /**
     * 
     * @type {string}
     * @memberof PagedResultPagingMetadata
     */
    cursor?: string;
}
/**
 * 
 * @export
 */
export type PathItem = string
/**
 * 
 * @export
 * @interface Property
 */
export interface Property extends DataElement {
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof Property
     */
    valueType: DataTypeDefXsd;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    value?: string;
    /**
     * 
     * @type {Reference}
     * @memberof Property
     */
    valueId?: Reference;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface PropertyMetadata
 */
export interface PropertyMetadata extends SubmodelElementAttributes {
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof PropertyMetadata
     */
    valueType?: DataTypeDefXsd;
}
/**
 * 
 * @export
 * @interface PropertyValue
 */
export interface PropertyValue {
}
/**
 * 
 * @export
 * @interface ProtocolInformation
 */
export interface ProtocolInformation {
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformation
     */
    href: string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformation
     */
    endpointProtocol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProtocolInformation
     */
    endpointProtocolVersion?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformation
     */
    subprotocol?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformation
     */
    subprotocolBody?: string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformation
     */
    subprotocolBodyEncoding?: string;
    /**
     * 
     * @type {Array<ProtocolInformationSecurityAttributes>}
     * @memberof ProtocolInformation
     */
    securityAttributes?: Array<ProtocolInformationSecurityAttributes>;
}
/**
 * 
 * @export
 * @interface ProtocolInformationSecurityAttributes
 */
export interface ProtocolInformationSecurityAttributes {
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformationSecurityAttributes
     */
    type: ProtocolInformationSecurityAttributes.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformationSecurityAttributes
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof ProtocolInformationSecurityAttributes
     */
    value: string;
}

/**
 * @export
 * @namespace ProtocolInformationSecurityAttributes
 */
export namespace ProtocolInformationSecurityAttributes {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        NONE = <any> 'NONE',
        RFCTLSA = <any> 'RFC_TLSA',
        W3CDID = <any> 'W3C_DID'
    }
}
/**
 * 
 * @export
 * @interface Qualifiable
 */
export interface Qualifiable {
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof Qualifiable
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof Qualifiable
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface Qualifier
 */
export interface Qualifier extends HasSemantics {
    /**
     * 
     * @type {QualifierKind}
     * @memberof Qualifier
     */
    kind?: QualifierKind;
    /**
     * 
     * @type {string}
     * @memberof Qualifier
     */
    type: string;
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof Qualifier
     */
    valueType: DataTypeDefXsd;
    /**
     * 
     * @type {string}
     * @memberof Qualifier
     */
    value?: string;
    /**
     * 
     * @type {Reference}
     * @memberof Qualifier
     */
    valueId?: Reference;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum QualifierKind {
    ConceptQualifier = <any> 'ConceptQualifier',
    TemplateQualifier = <any> 'TemplateQualifier',
    ValueQualifier = <any> 'ValueQualifier'
}
/**
 * 
 * @export
 * @interface Range
 */
export interface Range extends DataElement {
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof Range
     */
    valueType: DataTypeDefXsd;
    /**
     * 
     * @type {string}
     * @memberof Range
     */
    min?: string;
    /**
     * 
     * @type {string}
     * @memberof Range
     */
    max?: string;
    /**
     * 
     * @type {string}
     * @memberof Range
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface RangeMetadata
 */
export interface RangeMetadata extends SubmodelElementAttributes {
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof RangeMetadata
     */
    valueType?: DataTypeDefXsd;
}
/**
 * 
 * @export
 * @interface RangeValue
 */
export interface RangeValue {
    /**
     * 
     * @type {number}
     * @memberof RangeValue
     */
    max: number;
    /**
     * 
     * @type {number}
     * @memberof RangeValue
     */
    min: number;
}
/**
 * 
 * @export
 * @interface Referable
 */
export interface Referable extends HasExtensions {
    /**
     * 
     * @type {string}
     * @memberof Referable
     */
    category?: string;
    /**
     * 
     * @type {any}
     * @memberof Referable
     */
    idShort?: any;
    /**
     * 
     * @type {Array<LangStringNameType>}
     * @memberof Referable
     */
    displayName?: Array<LangStringNameType>;
    /**
     * 
     * @type {Array<LangStringTextType>}
     * @memberof Referable
     */
    description?: Array<LangStringTextType>;
    /**
     * 
     * @type {ModelType}
     * @memberof Referable
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface Reference
 */
export interface Reference extends ReferenceParent {
    /**
     * 
     * @type {ReferenceParent}
     * @memberof Reference
     */
    referredSemanticId?: ReferenceParent;
}
/**
 * 
 * @export
 * @interface ReferenceElement
 */
export interface ReferenceElement extends DataElement {
    /**
     * 
     * @type {Reference}
     * @memberof ReferenceElement
     */
    value?: Reference;
    /**
     * 
     * @type {string}
     * @memberof ReferenceElement
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface ReferenceElementMetadata
 */
export interface ReferenceElementMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface ReferenceElementValue
 */
export interface ReferenceElementValue {
    /**
     * 
     * @type {ReferenceTypes}
     * @memberof ReferenceElementValue
     */
    type?: ReferenceTypes;
    /**
     * 
     * @type {Array<Key>}
     * @memberof ReferenceElementValue
     */
    keys?: Array<Key>;
}
/**
 * 
 * @export
 * @interface ReferenceParent
 */
export interface ReferenceParent {
    /**
     * 
     * @type {ReferenceTypes}
     * @memberof ReferenceParent
     */
    type: ReferenceTypes;
    /**
     * 
     * @type {Array<Key>}
     * @memberof ReferenceParent
     */
    keys: Array<Key>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ReferenceTypes {
    ExternalReference = <any> 'ExternalReference',
    ModelReference = <any> 'ModelReference'
}
/**
 * 
 * @export
 * @interface ReferenceValue
 */
export interface ReferenceValue {
    /**
     * 
     * @type {ReferenceTypes}
     * @memberof ReferenceValue
     */
    type?: ReferenceTypes;
    /**
     * 
     * @type {Array<Key>}
     * @memberof ReferenceValue
     */
    keys?: Array<Key>;
}
/**
 * 
 * @export
 * @interface RelationshipElement
 */
export interface RelationshipElement extends RelationshipElementAbstract {
    /**
     * 
     * @type {string}
     * @memberof RelationshipElement
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface RelationshipElementAbstract
 */
export interface RelationshipElementAbstract extends SubmodelElement {
    /**
     * 
     * @type {Reference}
     * @memberof RelationshipElementAbstract
     */
    first: Reference;
    /**
     * 
     * @type {Reference}
     * @memberof RelationshipElementAbstract
     */
    second: Reference;
}
/**
 * 
 * @export
 * @interface RelationshipElementMetadata
 */
export interface RelationshipElementMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface RelationshipElementValue
 */
export interface RelationshipElementValue {
    /**
     * 
     * @type {ReferenceValue}
     * @memberof RelationshipElementValue
     */
    first: ReferenceValue;
    /**
     * 
     * @type {ReferenceValue}
     * @memberof RelationshipElementValue
     */
    second: ReferenceValue;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    path: any;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    contentType?: any;
}
/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {Array<Message>}
     * @memberof Result
     */
    messages?: Array<Message>;
}
/**
 * The Description object enables servers to present their capabilities to the clients, in particular which profiles they implement. At least one defined profile is required. Additional, proprietary attributes might be included. Nevertheless, the server must not expect that a regular client understands them.
 * @export
 * @interface ServiceDescription
 */
export interface ServiceDescription {
    /**
     * 
     * @type {Array<string>}
     * @memberof ServiceDescription
     */
    profiles?: Array<ServiceDescription.ProfilesEnum>;
}

/**
 * @export
 * @namespace ServiceDescription
 */
export namespace ServiceDescription {
    /**
     * @export
     * @enum {string}
     */
    export enum ProfilesEnum {
        AssetAdministrationShellServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellServiceSpecification/SSP-001',
        AssetAdministrationShellServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellServiceSpecification/SSP-002',
        SubmodelServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelServiceSpecification/SSP-001',
        SubmodelServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelServiceSpecification/SSP-002',
        SubmodelServiceSpecificationSSP003 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelServiceSpecification/SSP-003',
        AasxFileServerServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/AasxFileServerServiceSpecification/SSP-001',
        AssetAdministrationShellRegistryServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellRegistryServiceSpecification/SSP-001',
        AssetAdministrationShellRegistryServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellRegistryServiceSpecification/SSP-002',
        SubmodelRegistryServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRegistryServiceSpecification/SSP-001',
        SubmodelRegistryServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRegistryServiceSpecification/SSP-002',
        DiscoveryServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/DiscoveryServiceSpecification/SSP-001',
        AssetAdministrationShellRepositoryServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellRepositoryServiceSpecification/SSP-001',
        AssetAdministrationShellRepositoryServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/AssetAdministrationShellRepositoryServiceSpecification/SSP-002',
        SubmodelRepositoryServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRepositoryServiceSpecification/SSP-001',
        SubmodelRepositoryServiceSpecificationSSP002 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRepositoryServiceSpecification/SSP-002',
        SubmodelRepositoryServiceSpecificationSSP003 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRepositoryServiceSpecification/SSP-003',
        SubmodelRepositoryServiceSpecificationSSP004 = <any> 'https://admin-shell.io/aas/API/3/0/SubmodelRepositoryServiceSpecification/SSP-004',
        ConceptDescriptionServiceSpecificationSSP001 = <any> 'https://admin-shell.io/aas/API/3/0/ConceptDescriptionServiceSpecification/SSP-001'
    }
}
/**
 * 
 * @export
 * @interface SpecificAssetId
 */
export interface SpecificAssetId extends HasSemantics {
    /**
     * 
     * @type {string}
     * @memberof SpecificAssetId
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SpecificAssetId
     */
    value: string;
    /**
     * 
     * @type {Reference}
     * @memberof SpecificAssetId
     */
    externalSubjectId?: Reference;
}
/**
 * Since patternProperties and propertyNames are not supported by OpenApi yet, the ValueOnly serialization for this elements works with the key-attribute as the JSON-property name and the value-attribute as the corresponding value.
 * @export
 * @interface SpecificAssetIdValue
 */
export interface SpecificAssetIdValue {
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum StateOfEvent {
    Off = <any> 'off',
    On = <any> 'on'
}
/**
 * 
 * @export
 */
export type StringValue = string
/**
 * 
 * @export
 * @interface Submodel
 */
export interface Submodel extends Identifiable {
    /**
     * 
     * @type {ModellingKind}
     * @memberof Submodel
     */
    kind?: ModellingKind;
    /**
     * 
     * @type {Reference}
     * @memberof Submodel
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof Submodel
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof Submodel
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof Submodel
     */
    modelType: ModelType;
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof Submodel
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Array<SubmodelElementChoice>}
     * @memberof Submodel
     */
    submodelElements?: Array<SubmodelElementChoice>;
}
/**
 * 
 * @export
 * @interface SubmodelDescriptor
 */
export interface SubmodelDescriptor extends Descriptor {
    /**
     * 
     * @type {AdministrativeInformation}
     * @memberof SubmodelDescriptor
     */
    administration?: AdministrativeInformation;
    /**
     * 
     * @type {Array<Endpoint>}
     * @memberof SubmodelDescriptor
     */
    endpoints: Array<Endpoint>;
    /**
     * 
     * @type {string}
     * @memberof SubmodelDescriptor
     */
    idShort?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmodelDescriptor
     */
    id: string;
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelDescriptor
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof SubmodelDescriptor
     */
    supplementalSemanticId?: Array<Reference>;
}
/**
 * 
 * @export
 * @interface SubmodelElement
 */
export interface SubmodelElement extends Referable {
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelElement
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof SubmodelElement
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof SubmodelElement
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof SubmodelElement
     */
    modelType: ModelType;
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof SubmodelElement
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
}
/**
 * 
 * @export
 * @interface SubmodelElementAttributes
 */
export interface SubmodelElementAttributes extends Referable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof SubmodelElementAttributes
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelElementAttributes
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof SubmodelElementAttributes
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof SubmodelElementAttributes
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof SubmodelElementAttributes
     */
    modelType: ModelType;
    /**
     * 
     * @type {ModellingKind}
     * @memberof SubmodelElementAttributes
     */
    kind?: ModellingKind;
}
/**
 * 
 * @export
 * @interface SubmodelElementChoice
 */
export interface SubmodelElementChoice {
}
/**
 * 
 * @export
 * @interface SubmodelElementCollection
 */
export interface SubmodelElementCollection extends SubmodelElement {
    /**
     * 
     * @type {Array<SubmodelElementChoice>}
     * @memberof SubmodelElementCollection
     */
    value?: Array<SubmodelElementChoice>;
    /**
     * 
     * @type {string}
     * @memberof SubmodelElementCollection
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface SubmodelElementCollectionMetadata
 */
export interface SubmodelElementCollectionMetadata extends SubmodelElementAttributes {
}
/**
 * Since patternProperties and propertyNames are not supported by OpenApi yet, the ValueOnly serialization for this elements works with the key-attribute as the JSON-property name and the value-attribute as the corresponding value.
 * @export
 * @interface SubmodelElementCollectionValue
 */
export interface SubmodelElementCollectionValue {
}
/**
 * 
 * @export
 * @interface SubmodelElementList
 */
export interface SubmodelElementList extends SubmodelElement {
    /**
     * 
     * @type {boolean}
     * @memberof SubmodelElementList
     */
    orderRelevant?: boolean;
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelElementList
     */
    semanticIdListElement?: Reference;
    /**
     * 
     * @type {AasSubmodelElements}
     * @memberof SubmodelElementList
     */
    typeValueListElement: AasSubmodelElements;
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof SubmodelElementList
     */
    valueTypeListElement?: DataTypeDefXsd;
    /**
     * 
     * @type {Array<SubmodelElementChoice>}
     * @memberof SubmodelElementList
     */
    value?: Array<SubmodelElementChoice>;
    /**
     * 
     * @type {string}
     * @memberof SubmodelElementList
     */
    modelType: ModelType;
}
/**
 * 
 * @export
 * @interface SubmodelElementListMetadata
 */
export interface SubmodelElementListMetadata extends SubmodelElementAttributes {
    /**
     * 
     * @type {boolean}
     * @memberof SubmodelElementListMetadata
     */
    orderRelevant?: boolean;
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelElementListMetadata
     */
    semanticIdListElement?: Reference;
    /**
     * 
     * @type {ModelType}
     * @memberof SubmodelElementListMetadata
     */
    typeValueListElement?: ModelType;
    /**
     * 
     * @type {DataTypeDefXsd}
     * @memberof SubmodelElementListMetadata
     */
    valueTypeListElement?: DataTypeDefXsd;
}
/**
 * 
 * @export
 */
export type SubmodelElementListValue = Array<SubmodelElementValue>
/**
 * 
 * @export
 * @interface SubmodelElementMetadata
 */
export interface SubmodelElementMetadata extends SubmodelElementAttributes {
}
/**
 * 
 * @export
 * @interface SubmodelElementValue
 */
export interface SubmodelElementValue {
}
/**
 * 
 * @export
 * @interface SubmodelMetadata
 */
export interface SubmodelMetadata extends Identifiable {
    /**
     * 
     * @type {Array<EmbeddedDataSpecification>}
     * @memberof SubmodelMetadata
     */
    embeddedDataSpecifications?: Array<EmbeddedDataSpecification>;
    /**
     * 
     * @type {Array<Qualifier>}
     * @memberof SubmodelMetadata
     */
    qualifiers?: Array<Qualifier>;
    /**
     * 
     * @type {ModelType}
     * @memberof SubmodelMetadata
     */
    modelType: ModelType;
    /**
     * 
     * @type {Reference}
     * @memberof SubmodelMetadata
     */
    semanticId?: Reference;
    /**
     * 
     * @type {Array<Reference>}
     * @memberof SubmodelMetadata
     */
    supplementalSemanticIds?: Array<Reference>;
    /**
     * 
     * @type {ModellingKind}
     * @memberof SubmodelMetadata
     */
    kind?: ModellingKind;
}
/**
 * 
 * @export
 * @interface SubmodelValue
 */
export interface SubmodelValue {
    /**
     * 
     * @type {Array<SubmodelElement>}
     * @memberof SubmodelValue
     */
    submodelElements?: Array<SubmodelElement>;
}
/**
 * 
 * @export
 * @interface ValueList
 */
export interface ValueList {
    /**
     * 
     * @type {Array<ValueReferencePair>}
     * @memberof ValueList
     */
    valueReferencePairs: Array<ValueReferencePair>;
}
/**
 * The ValueOnly serialization of submodel elements (patternProperties and propertyNames will be supported propably with OpenApi 3.1). The full description of the generic JSON validation schema for the ValueOnly-serialization can be found in chapter 11.4.3 in Details of the Asset Administration Shell Part 2. 
 * @export
 * @interface ValueOnly
 */
export interface ValueOnly {
}
/**
 * 
 * @export
 * @interface ValueReferencePair
 */
export interface ValueReferencePair {
    /**
     * 
     * @type {string}
     * @memberof ValueReferencePair
     */
    value: string;
    /**
     * 
     * @type {Reference}
     * @memberof ValueReferencePair
     */
    valueId: Reference;
}
/**
 * AASXFileServerAPIApi - fetch parameter creator
 * @export
 */
export const AASXFileServerAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAASXByPackageId(packageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling deleteAASXByPackageId.');
            }
            const localVarPath = `/packages/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAASXByPackageId(packageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling getAASXByPackageId.');
            }
            const localVarPath = `/packages/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of available AASX packages at the server
         * @param {string} [aasId] The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAASXPackageIds(aasId?: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/packages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aasId !== undefined) {
                localVarQueryParameter['aasId'] = aasId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stores the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAASXPackage(aasIds: Array<string>, file: Blob, fileName: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIds' is not null or undefined
            if (aasIds === null || aasIds === undefined) {
                throw new RequiredError('aasIds','Required parameter aasIds was null or undefined when calling postAASXPackage.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling postAASXPackage.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling postAASXPackage.');
            }
            const localVarPath = `/packages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (aasIds) {
                aasIds.forEach((element) => {
                    localVarFormParams.append('aasIds', element as any);
                })
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAASXByPackageId(aasIds: Array<string>, file: Blob, fileName: string, packageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIds' is not null or undefined
            if (aasIds === null || aasIds === undefined) {
                throw new RequiredError('aasIds','Required parameter aasIds was null or undefined when calling putAASXByPackageId.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putAASXByPackageId.');
            }
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putAASXByPackageId.');
            }
            // verify required parameter 'packageId' is not null or undefined
            if (packageId === null || packageId === undefined) {
                throw new RequiredError('packageId','Required parameter packageId was null or undefined when calling putAASXByPackageId.');
            }
            const localVarPath = `/packages/{packageId}`
                .replace(`{${"packageId"}}`, encodeURIComponent(String(packageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (aasIds) {
                aasIds.forEach((element) => {
                    localVarFormParams.append('aasIds', element as any);
                })
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AASXFileServerAPIApi - functional programming interface
 * @export
 */
export const AASXFileServerAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAASXByPackageId(packageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AASXFileServerAPIApiFetchParamCreator(configuration).deleteAASXByPackageId(packageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAASXByPackageId(packageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = AASXFileServerAPIApiFetchParamCreator(configuration).getAASXByPackageId(packageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of available AASX packages at the server
         * @param {string} [aasId] The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAASXPackageIds(aasId?: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPackageDescriptionsResult> {
            const localVarFetchArgs = AASXFileServerAPIApiFetchParamCreator(configuration).getAllAASXPackageIds(aasId, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Stores the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAASXPackage(aasIds: Array<string>, file: Blob, fileName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PackageDescription> {
            const localVarFetchArgs = AASXFileServerAPIApiFetchParamCreator(configuration).postAASXPackage(aasIds, file, fileName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAASXByPackageId(aasIds: Array<string>, file: Blob, fileName: string, packageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AASXFileServerAPIApiFetchParamCreator(configuration).putAASXByPackageId(aasIds, file, fileName, packageId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AASXFileServerAPIApi - factory interface
 * @export
 */
export const AASXFileServerAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAASXByPackageId(packageId: string, options?: any) {
            return AASXFileServerAPIApiFp(configuration).deleteAASXByPackageId(packageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific AASX package from the server
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAASXByPackageId(packageId: string, options?: any) {
            return AASXFileServerAPIApiFp(configuration).getAASXByPackageId(packageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of available AASX packages at the server
         * @param {string} [aasId] The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAASXPackageIds(aasId?: string, limit?: number, cursor?: string, options?: any) {
            return AASXFileServerAPIApiFp(configuration).getAllAASXPackageIds(aasId, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Stores the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAASXPackage(aasIds: Array<string>, file: Blob, fileName: string, options?: any) {
            return AASXFileServerAPIApiFp(configuration).postAASXPackage(aasIds, file, fileName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the AASX package at the server
         * @param {Array<string>} aasIds 
         * @param {Blob} file 
         * @param {string} fileName 
         * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAASXByPackageId(aasIds: Array<string>, file: Blob, fileName: string, packageId: string, options?: any) {
            return AASXFileServerAPIApiFp(configuration).putAASXByPackageId(aasIds, file, fileName, packageId, options)(fetch, basePath);
        },
    };
};

/**
 * AASXFileServerAPIApi - object-oriented interface
 * @export
 * @class AASXFileServerAPIApi
 * @extends {BaseAPI}
 */
export class AASXFileServerAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a specific AASX package from the server
     * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AASXFileServerAPIApi
     */
    public deleteAASXByPackageId(packageId: string, options?: any) {
        return AASXFileServerAPIApiFp(this.configuration).deleteAASXByPackageId(packageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific AASX package from the server
     * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AASXFileServerAPIApi
     */
    public getAASXByPackageId(packageId: string, options?: any) {
        return AASXFileServerAPIApiFp(this.configuration).getAASXByPackageId(packageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of available AASX packages at the server
     * @param {string} [aasId] The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AASXFileServerAPIApi
     */
    public getAllAASXPackageIds(aasId?: string, limit?: number, cursor?: string, options?: any) {
        return AASXFileServerAPIApiFp(this.configuration).getAllAASXPackageIds(aasId, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Stores the AASX package at the server
     * @param {Array<string>} aasIds 
     * @param {Blob} file 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AASXFileServerAPIApi
     */
    public postAASXPackage(aasIds: Array<string>, file: Blob, fileName: string, options?: any) {
        return AASXFileServerAPIApiFp(this.configuration).postAASXPackage(aasIds, file, fileName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the AASX package at the server
     * @param {Array<string>} aasIds 
     * @param {Blob} file 
     * @param {string} fileName 
     * @param {string} packageId The package Id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AASXFileServerAPIApi
     */
    public putAASXByPackageId(aasIds: Array<string>, file: Blob, fileName: string, packageId: string, options?: any) {
        return AASXFileServerAPIApiFp(this.configuration).putAASXByPackageId(aasIds, file, fileName, packageId, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetAdministrationShellAPIApi - fetch parameter creator
 * @export
 */
export const AssetAdministrationShellAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAAS(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteFileByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteFileByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell.
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAAS(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelByIdAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelElementByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceById(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelReferenceById.');
            }
            const localVarPath = `/aas/submodel-refs/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnail(options: any = {}): FetchArgs {
            const localVarPath = `/aas/asset-information/thumbnail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsMetadataAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsReferenceAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferences(limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/aas/submodel-refs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShell(options: any = {}): FetchArgs {
            const localVarPath = `/aas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellReference(options: any = {}): FetchArgs {
            const localVarPath = `/aas/$reference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformation(options: any = {}): FetchArgs {
            const localVarPath = `/aas/asset-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAAS(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getFileByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getFileByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultAAS.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncResultAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultAAS.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultValueOnlyAAS.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncResultValueOnlyAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultValueOnlyAAS.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncStatusAAS.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncStatusAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncStatusAAS.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncStatusAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-status/{handleId}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelAAS(submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAAS(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathMetadataAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathMetadataAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAAS(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathReferenceAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathReferenceAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAAS(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathValueOnlyAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataAAS(submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelMetadataAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataReferenceAAS(submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelMetadataReferenceAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPathAAS(submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnlyAAS(submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnail(options: any = {}): FetchArgs {
            const localVarPath = `/aas/asset-information/thumbnail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncValueOnlyAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncValueOnlyAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-asnyc/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationSyncAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationSyncAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationSyncAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationSyncValueOnlyAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationSyncValueOnlyAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationSyncValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadataAAS(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathMetadataAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathMetadataAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathMetadataAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnlyAAS(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathValueOnlyAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathValueOnlyAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadataAAS(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelMetadataAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelMetadataAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnlyAAS(body: SubmodelValue, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelValueOnlyAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelValueOnlyAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAAS(body: SubmodelElement, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementByPathAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling postSubmodelElementByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReference(body: Reference, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelReference.');
            }
            const localVarPath = `/aas/submodel-refs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Reference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShell(body: AssetAdministrationShell, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAssetAdministrationShell.');
            }
            const localVarPath = `/aas`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetAdministrationShell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformation(body: AssetInformation, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAssetInformation.');
            }
            const localVarPath = `/aas/asset-information`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetInformation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAAS(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putFileByPathAAS.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putFileByPathAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putFileByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putFileByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelElementByPathAAS.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelElementByPathAAS.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putSubmodelElementByPathAAS.');
            }
            const localVarPath = `/aas/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnail(fileName: string, file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putThumbnail.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putThumbnail.');
            }
            const localVarPath = `/aas/asset-information/thumbnail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetAdministrationShellAPIApi - functional programming interface
 * @export
 */
export const AssetAdministrationShellAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).deleteFileByPathAAS(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell.
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAAS(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).deleteSubmodelByIdAAS(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).deleteSubmodelElementByPathAAS(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceById(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).deleteSubmodelReferenceById(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).deleteThumbnail(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelElementsAAS(submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsMetadataResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelElementsMetadataAAS(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPathItemsResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelElementsPathAAS(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelElementsReferenceAAS(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsValueResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelElementsValueOnlyAAS(submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferences(limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAllSubmodelReferences(limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShell(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetAdministrationShell> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAssetAdministrationShell(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellReference(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAssetAdministrationShellReference(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetInformation> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getAssetInformation(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getFileByPathAAS(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getOperationAsyncResultAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getOperationAsyncResultValueOnlyAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseOperationResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getOperationAsyncStatusAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submodel> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelAAS(submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelElementByPathAAS(submodelIdentifier, idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementMetadata> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelElementByPathMetadataAAS(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PathItem> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelElementByPathPathAAS(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelElementByPathReferenceAAS(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementValue> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelElementByPathValueOnlyAAS(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataAAS(submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelMetadata> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelMetadataAAS(submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataReferenceAAS(submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelMetadataReferenceAAS(submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPathAAS(submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PathItem>> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelPathAAS(submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnlyAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelValue> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getSubmodelValueOnlyAAS(submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).getThumbnail(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).invokeOperationAsyncAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).invokeOperationAsyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).invokeOperationSyncAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).invokeOperationSyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelAAS(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathAAS(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadataAAS(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathMetadataAAS(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnlyAAS(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathValueOnlyAAS(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadataAAS(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelMetadataAAS(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnlyAAS(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).patchSubmodelValueOnlyAAS(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAAS(body: SubmodelElement, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).postSubmodelElementAAS(body, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).postSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReference(body: Reference, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).postSubmodelReference(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShell(body: AssetAdministrationShell, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putAssetAdministrationShell(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformation(body: AssetInformation, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putAssetInformation(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAAS(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putFileByPathAAS(fileName, file, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putSubmodelAAS(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnail(fileName: string, file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellAPIApiFetchParamCreator(configuration).putThumbnail(fileName, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetAdministrationShellAPIApi - factory interface
 * @export
 */
export const AssetAdministrationShellAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).deleteFileByPathAAS(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell.
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAAS(submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).deleteSubmodelByIdAAS(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).deleteSubmodelElementByPathAAS(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceById(submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).deleteSubmodelReferenceById(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnail(options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).deleteThumbnail(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelElementsAAS(submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelElementsMetadataAAS(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelElementsPathAAS(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelElementsReferenceAAS(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelElementsValueOnlyAAS(submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferences(limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAllSubmodelReferences(limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShell(options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAssetAdministrationShell(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellReference(options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAssetAdministrationShellReference(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformation(options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getAssetInformation(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getFileByPathAAS(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getOperationAsyncResultAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getOperationAsyncResultValueOnlyAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getOperationAsyncStatusAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelAAS(submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelElementByPathAAS(submodelIdentifier, idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelElementByPathMetadataAAS(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelElementByPathPathAAS(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelElementByPathReferenceAAS(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelElementByPathValueOnlyAAS(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataAAS(submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelMetadataAAS(submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadataReferenceAAS(submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelMetadataReferenceAAS(submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPathAAS(submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelPathAAS(submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnlyAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getSubmodelValueOnlyAAS(submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnail(options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).getThumbnail(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).invokeOperationAsyncAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).invokeOperationAsyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).invokeOperationSyncAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).invokeOperationSyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelAAS(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelElementValueByPathAAS(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadataAAS(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelElementValueByPathMetadataAAS(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnlyAAS(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelElementValueByPathValueOnlyAAS(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadataAAS(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelMetadataAAS(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnlyAAS(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).patchSubmodelValueOnlyAAS(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAAS(body: SubmodelElement, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).postSubmodelElementAAS(body, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).postSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReference(body: Reference, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).postSubmodelReference(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShell(body: AssetAdministrationShell, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putAssetAdministrationShell(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformation(body: AssetInformation, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putAssetInformation(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAAS(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putFileByPathAAS(fileName, file, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putSubmodelAAS(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnail(fileName: string, file: Blob, options?: any) {
            return AssetAdministrationShellAPIApiFp(configuration).putThumbnail(fileName, file, options)(fetch, basePath);
        },
    };
};

/**
 * AssetAdministrationShellAPIApi - object-oriented interface
 * @export
 * @class AssetAdministrationShellAPIApi
 * @extends {BaseAPI}
 */
export class AssetAdministrationShellAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public deleteFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).deleteFileByPathAAS(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the submodel from the Asset Administration Shell.
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public deleteSubmodelByIdAAS(submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).deleteSubmodelByIdAAS(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public deleteSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).deleteSubmodelElementByPathAAS(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public deleteSubmodelReferenceById(submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).deleteSubmodelReferenceById(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public deleteThumbnail(options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).deleteThumbnail(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelElementsAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelElementsAAS(submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelElementsMetadataAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelElementsMetadataAAS(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelElementsPathAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelElementsPathAAS(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements as a list of References
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelElementsReferenceAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelElementsReferenceAAS(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelElementsValueOnlyAAS(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelElementsValueOnlyAAS(submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel references
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAllSubmodelReferences(limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAllSubmodelReferences(limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Asset Administration Shell
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAssetAdministrationShell(options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAssetAdministrationShell(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Asset Administration Shell as a Reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAssetAdministrationShellReference(options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAssetAdministrationShellReference(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Asset Information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getAssetInformation(options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getAssetInformation(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getFileByPathAAS(submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getFileByPathAAS(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation result of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getOperationAsyncResultAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getOperationAsyncResultAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the value of the Operation result of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getOperationAsyncResultValueOnlyAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getOperationAsyncResultValueOnlyAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation status of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getOperationAsyncStatusAAS(submodelIdentifier: string, aasIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getOperationAsyncStatusAAS(submodelIdentifier, aasIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelAAS(submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelElementByPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelElementByPathAAS(submodelIdentifier, idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelElementByPathMetadataAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelElementByPathMetadataAAS(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelElementByPathPathAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelElementByPathPathAAS(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelElementByPathReferenceAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelElementByPathReferenceAAS(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelElementByPathValueOnlyAAS(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelElementByPathValueOnlyAAS(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's metadata elements
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelMetadataAAS(submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelMetadataAAS(submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel as a Reference
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelMetadataReferenceAAS(submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelMetadataReferenceAAS(submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's metadata elements
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelPathAAS(submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelPathAAS(submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getSubmodelValueOnlyAAS(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getSubmodelValueOnlyAAS(submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public getThumbnail(options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).getThumbnail(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public invokeOperationAsyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).invokeOperationAsyncAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public invokeOperationAsyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).invokeOperationAsyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public invokeOperationSyncAAS(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).invokeOperationSyncAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public invokeOperationSyncValueOnlyAAS(body: OperationRequestValueOnly, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).invokeOperationSyncValueOnlyAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelAAS(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body The updated value of the submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelElementValueByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelElementValueByPathAAS(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelElementValueByPathMetadataAAS(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelElementValueByPathMetadataAAS(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElementValue} body The updated value of the submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelElementValueByPathValueOnlyAAS(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelElementValueByPathValueOnlyAAS(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of the Submodel
     * @param {SubmodelMetadata} body Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelMetadataAAS(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelMetadataAAS(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates teh values of the Submodel
     * @param {SubmodelValue} body Submodel object in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public patchSubmodelValueOnlyAAS(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).patchSubmodelValueOnlyAAS(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public postSubmodelElementAAS(body: SubmodelElement, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).postSubmodelElementAAS(body, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public postSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).postSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a submodel reference at the Asset Administration Shell
     * @param {Reference} body Reference to the Submodel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public postSubmodelReference(body: Reference, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).postSubmodelReference(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Asset Administration Shell
     * @param {AssetAdministrationShell} body Asset Administration Shell object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putAssetAdministrationShell(body: AssetAdministrationShell, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putAssetAdministrationShell(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Asset Information
     * @param {AssetInformation} body Asset Information object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putAssetInformation(body: AssetInformation, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putAssetInformation(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putFileByPathAAS(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putFileByPathAAS(fileName, file, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putSubmodelAAS(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putSubmodelAAS(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putSubmodelElementByPathAAS(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putSubmodelElementByPathAAS(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellAPIApi
     */
    public putThumbnail(fileName: string, file: Blob, options?: any) {
        return AssetAdministrationShellAPIApiFp(this.configuration).putThumbnail(fileName, file, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetAdministrationShellBasicDiscoveryAPIApi - fetch parameter creator
 * @export
 */
export const AssetAdministrationShellBasicDiscoveryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllAssetLinksById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteAllAssetLinksById.');
            }
            const localVarPath = `/lookup/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of Asset Administration Shell ids linked to specific Asset identifiers
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellIdsByAssetLink(assetIds?: Array<string>, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/lookup/shells`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetIds) {
                localVarQueryParameter['assetIds'] = assetIds;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of specific Asset identifiers based on an Asset Administration Shell id to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetLinksById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllAssetLinksById.');
            }
            const localVarPath = `/lookup/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {Array<SpecificAssetId>} body A list of specific Asset identifiers
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllAssetLinksById(body: Array<SpecificAssetId>, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAllAssetLinksById.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling postAllAssetLinksById.');
            }
            const localVarPath = `/lookup/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SpecificAssetId&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetAdministrationShellBasicDiscoveryAPIApi - functional programming interface
 * @export
 */
export const AssetAdministrationShellBasicDiscoveryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes all specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllAssetLinksById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellBasicDiscoveryAPIApiFetchParamCreator(configuration).deleteAllAssetLinksById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of Asset Administration Shell ids linked to specific Asset identifiers
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellIdsByAssetLink(assetIds?: Array<string>, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = AssetAdministrationShellBasicDiscoveryAPIApiFetchParamCreator(configuration).getAllAssetAdministrationShellIdsByAssetLink(assetIds, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of specific Asset identifiers based on an Asset Administration Shell id to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetLinksById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecificAssetId>> {
            const localVarFetchArgs = AssetAdministrationShellBasicDiscoveryAPIApiFetchParamCreator(configuration).getAllAssetLinksById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {Array<SpecificAssetId>} body A list of specific Asset identifiers
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllAssetLinksById(body: Array<SpecificAssetId>, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecificAssetId>> {
            const localVarFetchArgs = AssetAdministrationShellBasicDiscoveryAPIApiFetchParamCreator(configuration).postAllAssetLinksById(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetAdministrationShellBasicDiscoveryAPIApi - factory interface
 * @export
 */
export const AssetAdministrationShellBasicDiscoveryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes all specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllAssetLinksById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellBasicDiscoveryAPIApiFp(configuration).deleteAllAssetLinksById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of Asset Administration Shell ids linked to specific Asset identifiers
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellIdsByAssetLink(assetIds?: Array<string>, limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellBasicDiscoveryAPIApiFp(configuration).getAllAssetAdministrationShellIdsByAssetLink(assetIds, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of specific Asset identifiers based on an Asset Administration Shell id to edit discoverable content
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetLinksById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellBasicDiscoveryAPIApiFp(configuration).getAllAssetLinksById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
         * @param {Array<SpecificAssetId>} body A list of specific Asset identifiers
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAllAssetLinksById(body: Array<SpecificAssetId>, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellBasicDiscoveryAPIApiFp(configuration).postAllAssetLinksById(body, aasIdentifier, options)(fetch, basePath);
        },
    };
};

/**
 * AssetAdministrationShellBasicDiscoveryAPIApi - object-oriented interface
 * @export
 * @class AssetAdministrationShellBasicDiscoveryAPIApi
 * @extends {BaseAPI}
 */
export class AssetAdministrationShellBasicDiscoveryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes all specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellBasicDiscoveryAPIApi
     */
    public deleteAllAssetLinksById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellBasicDiscoveryAPIApiFp(this.configuration).deleteAllAssetLinksById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of Asset Administration Shell ids linked to specific Asset identifiers
     * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellBasicDiscoveryAPIApi
     */
    public getAllAssetAdministrationShellIdsByAssetLink(assetIds?: Array<string>, limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellBasicDiscoveryAPIApiFp(this.configuration).getAllAssetAdministrationShellIdsByAssetLink(assetIds, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of specific Asset identifiers based on an Asset Administration Shell id to edit discoverable content
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellBasicDiscoveryAPIApi
     */
    public getAllAssetLinksById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellBasicDiscoveryAPIApiFp(this.configuration).getAllAssetLinksById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates specific Asset identifiers linked to an Asset Administration Shell to edit discoverable content
     * @param {Array<SpecificAssetId>} body A list of specific Asset identifiers
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellBasicDiscoveryAPIApi
     */
    public postAllAssetLinksById(body: Array<SpecificAssetId>, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellBasicDiscoveryAPIApiFp(this.configuration).postAllAssetLinksById(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetAdministrationShellRegistryAPIApi - fetch parameter creator
 * @export
 */
export const AssetAdministrationShellRegistryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell Descriptor, i.e. de-registers an AAS
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellDescriptorById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteAssetAdministrationShellDescriptorById.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteSubmodelDescriptorByIdThroughSuperpath.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelDescriptorByIdThroughSuperpath.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Asset Administration Shell Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {AssetKind} [assetKind] The Asset&#x27;s kind (Instance or Type)
         * @param {string} [assetType] The Asset&#x27;s type (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellDescriptors(limit?: number, cursor?: string, assetKind?: AssetKind, assetType?: string, options: any = {}): FetchArgs {
            const localVarPath = `/shell-descriptors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (assetKind !== undefined) {
                localVarQueryParameter['assetKind'] = assetKind;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['assetType'] = assetType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelDescriptorsThroughSuperpath.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}/submodel-descriptors`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellDescriptorById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAssetAdministrationShellDescriptorById.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelDescriptorByIdThroughSuperpath.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelDescriptorByIdThroughSuperpath.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell Descriptor, i.e. registers an AAS
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShellDescriptor(body: AssetAdministrationShellDescriptor, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAssetAdministrationShellDescriptor.');
            }
            const localVarPath = `/shell-descriptors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetAdministrationShellDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptorThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelDescriptorThroughSuperpath.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling postSubmodelDescriptorThroughSuperpath.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}/submodel-descriptors`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell Descriptor
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellDescriptorById(body: AssetAdministrationShellDescriptor, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAssetAdministrationShellDescriptorById.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putAssetAdministrationShellDescriptorById.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetAdministrationShellDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorByIdThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelDescriptorByIdThroughSuperpath.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putSubmodelDescriptorByIdThroughSuperpath.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelDescriptorByIdThroughSuperpath.');
            }
            const localVarPath = `/shell-descriptors/{aasIdentifier}/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetAdministrationShellRegistryAPIApi - functional programming interface
 * @export
 */
export const AssetAdministrationShellRegistryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell Descriptor, i.e. de-registers an AAS
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).deleteAssetAdministrationShellDescriptorById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Asset Administration Shell Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {AssetKind} [assetKind] The Asset&#x27;s kind (Instance or Type)
         * @param {string} [assetType] The Asset&#x27;s type (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellDescriptors(limit?: number, cursor?: string, assetKind?: AssetKind, assetType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssetAdministrationShellDescriptorsResult> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).getAllAssetAdministrationShellDescriptors(limit, cursor, assetKind, assetType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelDescriptorsResult> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetAdministrationShellDescriptor> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).getAssetAdministrationShellDescriptorById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelDescriptor> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell Descriptor, i.e. registers an AAS
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShellDescriptor(body: AssetAdministrationShellDescriptor, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetAdministrationShellDescriptor> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).postAssetAdministrationShellDescriptor(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptorThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelDescriptor> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).postSubmodelDescriptorThroughSuperpath(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell Descriptor
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellDescriptorById(body: AssetAdministrationShellDescriptor, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).putAssetAdministrationShellDescriptorById(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorByIdThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRegistryAPIApiFetchParamCreator(configuration).putSubmodelDescriptorByIdThroughSuperpath(body, aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetAdministrationShellRegistryAPIApi - factory interface
 * @export
 */
export const AssetAdministrationShellRegistryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell Descriptor, i.e. de-registers an AAS
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).deleteAssetAdministrationShellDescriptorById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Asset Administration Shell Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {AssetKind} [assetKind] The Asset&#x27;s kind (Instance or Type)
         * @param {string} [assetType] The Asset&#x27;s type (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellDescriptors(limit?: number, cursor?: string, assetKind?: AssetKind, assetType?: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).getAllAssetAdministrationShellDescriptors(limit, cursor, assetKind, assetType, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier: string, limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).getAssetAdministrationShellDescriptorById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell Descriptor, i.e. registers an AAS
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShellDescriptor(body: AssetAdministrationShellDescriptor, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).postAssetAdministrationShellDescriptor(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptorThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).postSubmodelDescriptorThroughSuperpath(body, aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell Descriptor
         * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellDescriptorById(body: AssetAdministrationShellDescriptor, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).putAssetAdministrationShellDescriptorById(body, aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorByIdThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRegistryAPIApiFp(configuration).putSubmodelDescriptorByIdThroughSuperpath(body, aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
    };
};

/**
 * AssetAdministrationShellRegistryAPIApi - object-oriented interface
 * @export
 * @class AssetAdministrationShellRegistryAPIApi
 * @extends {BaseAPI}
 */
export class AssetAdministrationShellRegistryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an Asset Administration Shell Descriptor, i.e. de-registers an AAS
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public deleteAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).deleteAssetAdministrationShellDescriptorById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).deleteSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Asset Administration Shell Descriptors
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {AssetKind} [assetKind] The Asset&#x27;s kind (Instance or Type)
     * @param {string} [assetType] The Asset&#x27;s type (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public getAllAssetAdministrationShellDescriptors(limit?: number, cursor?: string, assetKind?: AssetKind, assetType?: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).getAllAssetAdministrationShellDescriptors(limit, cursor, assetKind, assetType, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Submodel Descriptors
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier: string, limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).getAllSubmodelDescriptorsThroughSuperpath(aasIdentifier, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Asset Administration Shell Descriptor
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public getAssetAdministrationShellDescriptorById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).getAssetAdministrationShellDescriptorById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Submodel Descriptor
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).getSubmodelDescriptorByIdThroughSuperpath(aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Asset Administration Shell Descriptor, i.e. registers an AAS
     * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public postAssetAdministrationShellDescriptor(body: AssetAdministrationShellDescriptor, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).postAssetAdministrationShellDescriptor(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
     * @param {SubmodelDescriptor} body Submodel Descriptor object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public postSubmodelDescriptorThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).postSubmodelDescriptorThroughSuperpath(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Asset Administration Shell Descriptor
     * @param {AssetAdministrationShellDescriptor} body Asset Administration Shell Descriptor object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public putAssetAdministrationShellDescriptorById(body: AssetAdministrationShellDescriptor, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).putAssetAdministrationShellDescriptorById(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Submodel Descriptor
     * @param {SubmodelDescriptor} body Submodel Descriptor object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRegistryAPIApi
     */
    public putSubmodelDescriptorByIdThroughSuperpath(body: SubmodelDescriptor, aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRegistryAPIApiFp(this.configuration).putSubmodelDescriptorByIdThroughSuperpath(body, aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetAdministrationShellRepositoryAPIApi - fetch parameter creator
 * @export
 */
export const AssetAdministrationShellRepositoryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteAssetAdministrationShellById.');
            }
            const localVarPath = `/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteFileByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteFileByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteFileByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell and the Repository.
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteSubmodelByIdAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelByIdAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteSubmodelReferenceByIdAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelReferenceByIdAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodel-refs/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnailAasRepository(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling deleteThumbnailAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/asset-information/thumbnail`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShells(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/shells`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetIds) {
                localVarQueryParameter['assetIds'] = assetIds;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns References to all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellsReference(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/shells/$reference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (assetIds) {
                localVarQueryParameter['assetIds'] = assetIds;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElementsAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElementsMetadataAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsMetadataAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/$metadata`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElementsPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/$path`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElementsReferenceAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsReferenceAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/$reference`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelElementsValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferencesAasRepository(aasIdentifier: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAllSubmodelReferencesAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodel-refs`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellById(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAssetAdministrationShellById.');
            }
            const localVarPath = `/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAssetAdministrationShellByIdReferenceAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/$reference`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformationAasRepository(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getAssetInformationAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/asset-information`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getFileByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getFileByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getFileByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncResultAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultAasRepository.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the ValueOnly notation of the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncResultValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultValueOnlyAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultValueOnlyAasRepository.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getOperationAsyncStatusAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncStatusAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncStatusAasRepository.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncStatusAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-status/{handleId}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelByIdAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelByIdMetadataAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdMetadataAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPathAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelByIdPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$path`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelByIdReferenceAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdReferenceAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$reference`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelByIdValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPathMetadataAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathMetadataAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathMetadataAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPathPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$path`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPathReferenceAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathReferenceAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathReferenceAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$reference`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getSubmodelElementByPathValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathValueOnlyAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailAasRepository(aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling getThumbnailAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/asset-information/thumbnail`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationAsyncAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncValueOnlyAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationAsyncValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncValueOnlyAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationValueOnlyAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationValueOnlyAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadataAasRepository(body: SubmodelMetadata, aasIdentifier: string, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelByIdMetadataAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelByIdMetadataAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelByIdMetadataAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnlyAasRepository(body: SubmodelValue, aasIdentifier: string, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelByIdValueOnlyAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelByIdValueOnlyAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelByIdValueOnlyAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelElementValueByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadata(body: SubmodelElementMetadata, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathMetadata.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelElementValueByPathMetadata.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathMetadata.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathMetadata.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnly(body: SubmodelElementValue, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementValueByPathValueOnly.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling patchSubmodelElementValueByPathValueOnly.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementValueByPathValueOnly.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementValueByPathValueOnly.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShell(body: AssetAdministrationShell, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postAssetAdministrationShell.');
            }
            const localVarPath = `/shells`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetAdministrationShell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling postSubmodelElementAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling postSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling postSubmodelElementByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReferenceAasRepository(body: Reference, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelReferenceAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling postSubmodelReferenceAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodel-refs`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Reference" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAssetAdministrationShellById.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putAssetAdministrationShellById.');
            }
            const localVarPath = `/shells/{aasIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetAdministrationShell" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformationAasRepository(body: AssetInformation, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putAssetInformationAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putAssetInformationAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/asset-information`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssetInformation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAasRepository(fileName: string, file: Blob, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putFileByPathAasRepository.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putFileByPathAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putFileByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putFileByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putFileByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelByIdAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelByIdAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putSubmodelByIdAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelByIdAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelElementByPathAasRepository.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putSubmodelElementByPathAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnailAasRepository(fileName: string, file: Blob, aasIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putThumbnailAasRepository.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putThumbnailAasRepository.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling putThumbnailAasRepository.');
            }
            const localVarPath = `/shells/{aasIdentifier}/asset-information/thumbnail`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetAdministrationShellRepositoryAPIApi - functional programming interface
 * @export
 */
export const AssetAdministrationShellRepositoryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteAssetAdministrationShellById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell and the Repository.
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteSubmodelReferenceByIdAasRepository(aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnailAasRepository(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).deleteThumbnailAasRepository(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShells(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetAssetAdministrationShellsResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllAssetAdministrationShells(assetIds, idShort, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns References to all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellsReference(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllAssetAdministrationShellsReference(assetIds, idShort, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsMetadataResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsMetadataAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPathItemsResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsPathAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsReferenceAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsValueResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferencesAasRepository(aasIdentifier: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelReferencesAasRepository(aasIdentifier, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellById(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetAdministrationShell> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAssetAdministrationShellById(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformationAasRepository(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetInformation> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getAssetInformationAasRepository(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncResultAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the ValueOnly notation of the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncResultValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseOperationResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncStatusAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submodel> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelMetadata> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdMetadataAasRepository(aasIdentifier, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPathAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PathItem>> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdPathAasRepository(aasIdentifier, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdReferenceAasRepository(aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelValue> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdValueOnlyAasRepository(aasIdentifier, submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementMetadata> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathMetadataAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PathItem> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathReferenceAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementValue> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailAasRepository(aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).getThumbnailAasRepository(aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).invokeOperationAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).invokeOperationAsyncAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).invokeOperationAsyncValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).invokeOperationValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelAasRepository(body, aasIdentifier, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadataAasRepository(body: SubmodelMetadata, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelByIdMetadataAasRepository(body, aasIdentifier, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnlyAasRepository(body: SubmodelValue, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelByIdValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadata(body: SubmodelElementMetadata, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathMetadata(body, aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnly(body: SubmodelElementValue, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementValueByPathValueOnly(body, aasIdentifier, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShell(body: AssetAdministrationShell, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssetAdministrationShell> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).postAssetAdministrationShell(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).postSubmodelElementAasRepository(body, aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).postSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReferenceAasRepository(body: Reference, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).postSubmodelReferenceAasRepository(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putAssetAdministrationShellById(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformationAasRepository(body: AssetInformation, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putAssetInformationAasRepository(body, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAasRepository(fileName: string, file: Blob, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putFileByPathAasRepository(fileName, file, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelByIdAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putSubmodelByIdAasRepository(body, aasIdentifier, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnailAasRepository(fileName: string, file: Blob, aasIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetAdministrationShellRepositoryAPIApiFetchParamCreator(configuration).putThumbnailAasRepository(fileName, file, aasIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetAdministrationShellRepositoryAPIApi - factory interface
 * @export
 */
export const AssetAdministrationShellRepositoryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes an Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetAdministrationShellById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteAssetAdministrationShellById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the submodel from the Asset Administration Shell and the Repository.
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelReferenceByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteSubmodelReferenceByIdAasRepository(aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThumbnailAasRepository(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).deleteThumbnailAasRepository(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShells(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllAssetAdministrationShells(assetIds, idShort, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns References to all Asset Administration Shells
         * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAssetAdministrationShellsReference(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllAssetAdministrationShellsReference(assetIds, idShort, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelElementsAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelElementsMetadataAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelElementsPathAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements as a list of References
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelElementsReferenceAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel references
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelReferencesAasRepository(aasIdentifier: string, limit?: number, cursor?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAllSubmodelReferencesAasRepository(aasIdentifier, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellById(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAssetAdministrationShellById(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Asset Administration Shell as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Asset Information
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetInformationAasRepository(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getAssetInformationAasRepository(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getOperationAsyncResultAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the ValueOnly notation of the Operation result of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getOperationAsyncResultValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getOperationAsyncStatusAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelByIdMetadataAasRepository(aasIdentifier, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's metadata elements
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPathAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelByIdPathAasRepository(aasIdentifier, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel as a Reference
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelByIdReferenceAasRepository(aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel's ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelByIdValueOnlyAasRepository(aasIdentifier, submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelElementByPathMetadataAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelElementByPathPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelElementByPathReferenceAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThumbnailAasRepository(aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).getThumbnailAasRepository(aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).invokeOperationAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).invokeOperationAsyncAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).invokeOperationAsyncValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).invokeOperationValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadataAasRepository(body: SubmodelMetadata, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelByIdMetadataAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates teh values of the Submodel
         * @param {SubmodelValue} body Submodel object in the ValueOnly representation
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnlyAasRepository(body: SubmodelValue, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelByIdValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelElementValueByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathMetadata(body: SubmodelElementMetadata, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelElementValueByPathMetadata(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
         * @param {SubmodelElementValue} body The updated value of the submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementValueByPathValueOnly(body: SubmodelElementValue, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).patchSubmodelElementValueByPathValueOnly(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetAdministrationShell(body: AssetAdministrationShell, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).postAssetAdministrationShell(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).postSubmodelElementAasRepository(body, aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).postSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a submodel reference at the Asset Administration Shell
         * @param {Reference} body Reference to the Submodel
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelReferenceAasRepository(body: Reference, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).postSubmodelReferenceAasRepository(body, aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Asset Administration Shell
         * @param {AssetAdministrationShell} body Asset Administration Shell object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putAssetAdministrationShellById(body, aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Asset Information
         * @param {AssetInformation} body Asset Information object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetInformationAasRepository(body: AssetInformation, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putAssetInformationAasRepository(body, aasIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathAasRepository(fileName: string, file: Blob, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putFileByPathAasRepository(fileName, file, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelByIdAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putSubmodelByIdAasRepository(body, aasIdentifier, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putThumbnailAasRepository(fileName: string, file: Blob, aasIdentifier: string, options?: any) {
            return AssetAdministrationShellRepositoryAPIApiFp(configuration).putThumbnailAasRepository(fileName, file, aasIdentifier, options)(fetch, basePath);
        },
    };
};

/**
 * AssetAdministrationShellRepositoryAPIApi - object-oriented interface
 * @export
 * @class AssetAdministrationShellRepositoryAPIApi
 * @extends {BaseAPI}
 */
export class AssetAdministrationShellRepositoryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes an Asset Administration Shell
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteAssetAdministrationShellById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteAssetAdministrationShellById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the submodel from the Asset Administration Shell and the Repository.
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the submodel reference from the Asset Administration Shell. Does not delete the submodel itself!
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteSubmodelReferenceByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteSubmodelReferenceByIdAasRepository(aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public deleteThumbnailAasRepository(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).deleteThumbnailAasRepository(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Asset Administration Shells
     * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllAssetAdministrationShells(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllAssetAdministrationShells(assetIds, idShort, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns References to all Asset Administration Shells
     * @param {Array<string>} [assetIds] A list of specific Asset identifiers. Each Asset identifier is a base64-url-encoded [SpecificAssetId](https://api.swaggerhub.com/domains/Plattform_i40/Part1-MetaModel-Schemas/V3.0.1#/components/schemas/SpecificAssetId)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllAssetAdministrationShellsReference(assetIds?: Array<string>, idShort?: string, limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllAssetAdministrationShellsReference(assetIds, idShort, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelElementsAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelElementsMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsMetadataAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelElementsPathAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsPathAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements as a list of References
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelElementsReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsReferenceAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsValueOnlyAasRepository(aasIdentifier, submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel references
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAllSubmodelReferencesAasRepository(aasIdentifier: string, limit?: number, cursor?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAllSubmodelReferencesAasRepository(aasIdentifier, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Asset Administration Shell
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAssetAdministrationShellById(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAssetAdministrationShellById(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Asset Administration Shell as a Reference
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAssetAdministrationShellByIdReferenceAasRepository(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Asset Information
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getAssetInformationAasRepository(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getAssetInformationAasRepository(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getFileByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getFileByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation result of an asynchronous invoked Operation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getOperationAsyncResultAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getOperationAsyncResultAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the ValueOnly notation of the Operation result of an asynchronous invoked Operation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getOperationAsyncResultValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getOperationAsyncResultValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation status of an asynchronous invoked Operation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getOperationAsyncStatusAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getOperationAsyncStatusAasRepository(aasIdentifier, submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelByIdAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelByIdAasRepository(aasIdentifier, submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's metadata elements
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelByIdMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelByIdMetadataAasRepository(aasIdentifier, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's metadata elements
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelByIdPathAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelByIdPathAasRepository(aasIdentifier, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel as a Reference
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelByIdReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelByIdReferenceAasRepository(aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel's ValueOnly representation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelByIdValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelByIdValueOnlyAasRepository(aasIdentifier, submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelElementByPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes if a specific submodel element from the Submodel at a specified path
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelElementByPathMetadataAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathMetadataAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelElementByPathPathAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathPathAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Reference of a specific submodel element from the Submodel at a specified path
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelElementByPathReferenceAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathReferenceAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathValueOnlyAasRepository(aasIdentifier, submodelIdentifier, idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public getThumbnailAasRepository(aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).getThumbnailAasRepository(aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public invokeOperationAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).invokeOperationAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public invokeOperationAsyncAasRepository(body: OperationRequest, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).invokeOperationAsyncAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public invokeOperationAsyncValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).invokeOperationAsyncValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public invokeOperationValueOnlyAasRepository(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).invokeOperationValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of the Submodel
     * @param {SubmodelMetadata} body Submodel object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelByIdMetadataAasRepository(body: SubmodelMetadata, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelByIdMetadataAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates teh values of the Submodel
     * @param {SubmodelValue} body Submodel object in the ValueOnly representation
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelByIdValueOnlyAasRepository(body: SubmodelValue, aasIdentifier: string, submodelIdentifier: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelByIdValueOnlyAasRepository(body, aasIdentifier, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body The updated value of the submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelElementValueByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelElementValueByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElementMetadata} body The updated metadata attributes of the submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelElementValueByPathMetadata(body: SubmodelElementMetadata, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelElementValueByPathMetadata(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the value of an existing submodel element value at a specified path within submodel elements hierarchy
     * @param {SubmodelElementValue} body The updated value of the submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public patchSubmodelElementValueByPathValueOnly(body: SubmodelElementValue, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).patchSubmodelElementValueByPathValueOnly(body, aasIdentifier, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Asset Administration Shell
     * @param {AssetAdministrationShell} body Asset Administration Shell object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public postAssetAdministrationShell(body: AssetAdministrationShell, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).postAssetAdministrationShell(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public postSubmodelElementAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).postSubmodelElementAasRepository(body, aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public postSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).postSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a submodel reference at the Asset Administration Shell
     * @param {Reference} body Reference to the Submodel
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public postSubmodelReferenceAasRepository(body: Reference, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).postSubmodelReferenceAasRepository(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Asset Administration Shell
     * @param {AssetAdministrationShell} body Asset Administration Shell object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putAssetAdministrationShellById(body: AssetAdministrationShell, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putAssetAdministrationShellById(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Asset Information
     * @param {AssetInformation} body Asset Information object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putAssetInformationAasRepository(body: AssetInformation, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putAssetInformationAasRepository(body, aasIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putFileByPathAasRepository(fileName: string, file: Blob, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putFileByPathAasRepository(fileName, file, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putSubmodelByIdAasRepository(body: Submodel, aasIdentifier: string, submodelIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putSubmodelByIdAasRepository(body, aasIdentifier, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putSubmodelElementByPathAasRepository(body: SubmodelElement, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putSubmodelElementByPathAasRepository(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetAdministrationShellRepositoryAPIApi
     */
    public putThumbnailAasRepository(fileName: string, file: Blob, aasIdentifier: string, options?: any) {
        return AssetAdministrationShellRepositoryAPIApiFp(this.configuration).putThumbnailAasRepository(fileName, file, aasIdentifier, options)(this.fetch, this.basePath);
    }

}
/**
 * ConceptDescriptionRepositoryAPIApi - fetch parameter creator
 * @export
 */
export const ConceptDescriptionRepositoryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConceptDescriptionById(cdIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'cdIdentifier' is not null or undefined
            if (cdIdentifier === null || cdIdentifier === undefined) {
                throw new RequiredError('cdIdentifier','Required parameter cdIdentifier was null or undefined when calling deleteConceptDescriptionById.');
            }
            const localVarPath = `/concept-descriptions/{cdIdentifier}`
                .replace(`{${"cdIdentifier"}}`, encodeURIComponent(String(cdIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Concept Descriptions
         * @param {string} [idShort] The Concept Descriptions IdShort
         * @param {string} [isCaseOf] IsCaseOf reference (UTF8-BASE64-URL-encoded)
         * @param {string} [dataSpecificationRef] DataSpecification reference (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/concept-descriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (isCaseOf !== undefined) {
                localVarQueryParameter['isCaseOf'] = isCaseOf;
            }

            if (dataSpecificationRef !== undefined) {
                localVarQueryParameter['dataSpecificationRef'] = dataSpecificationRef;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptDescriptionById(cdIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'cdIdentifier' is not null or undefined
            if (cdIdentifier === null || cdIdentifier === undefined) {
                throw new RequiredError('cdIdentifier','Required parameter cdIdentifier was null or undefined when calling getConceptDescriptionById.');
            }
            const localVarPath = `/concept-descriptions/{cdIdentifier}`
                .replace(`{${"cdIdentifier"}}`, encodeURIComponent(String(cdIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConceptDescription(body: ConceptDescription, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postConceptDescription.');
            }
            const localVarPath = `/concept-descriptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConceptDescription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putConceptDescriptionById.');
            }
            // verify required parameter 'cdIdentifier' is not null or undefined
            if (cdIdentifier === null || cdIdentifier === undefined) {
                throw new RequiredError('cdIdentifier','Required parameter cdIdentifier was null or undefined when calling putConceptDescriptionById.');
            }
            const localVarPath = `/concept-descriptions/{cdIdentifier}`
                .replace(`{${"cdIdentifier"}}`, encodeURIComponent(String(cdIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ConceptDescription" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConceptDescriptionRepositoryAPIApi - functional programming interface
 * @export
 */
export const ConceptDescriptionRepositoryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConceptDescriptionById(cdIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConceptDescriptionRepositoryAPIApiFetchParamCreator(configuration).deleteConceptDescriptionById(cdIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Concept Descriptions
         * @param {string} [idShort] The Concept Descriptions IdShort
         * @param {string} [isCaseOf] IsCaseOf reference (UTF8-BASE64-URL-encoded)
         * @param {string} [dataSpecificationRef] DataSpecification reference (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetConceptDescriptionsResult> {
            const localVarFetchArgs = ConceptDescriptionRepositoryAPIApiFetchParamCreator(configuration).getAllConceptDescriptions(idShort, isCaseOf, dataSpecificationRef, limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptDescriptionById(cdIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConceptDescription> {
            const localVarFetchArgs = ConceptDescriptionRepositoryAPIApiFetchParamCreator(configuration).getConceptDescriptionById(cdIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConceptDescription(body: ConceptDescription, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ConceptDescription> {
            const localVarFetchArgs = ConceptDescriptionRepositoryAPIApiFetchParamCreator(configuration).postConceptDescription(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ConceptDescriptionRepositoryAPIApiFetchParamCreator(configuration).putConceptDescriptionById(body, cdIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConceptDescriptionRepositoryAPIApi - factory interface
 * @export
 */
export const ConceptDescriptionRepositoryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes a Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConceptDescriptionById(cdIdentifier: string, options?: any) {
            return ConceptDescriptionRepositoryAPIApiFp(configuration).deleteConceptDescriptionById(cdIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Concept Descriptions
         * @param {string} [idShort] The Concept Descriptions IdShort
         * @param {string} [isCaseOf] IsCaseOf reference (UTF8-BASE64-URL-encoded)
         * @param {string} [dataSpecificationRef] DataSpecification reference (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, limit?: number, cursor?: string, options?: any) {
            return ConceptDescriptionRepositoryAPIApiFp(configuration).getAllConceptDescriptions(idShort, isCaseOf, dataSpecificationRef, limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Concept Description
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConceptDescriptionById(cdIdentifier: string, options?: any) {
            return ConceptDescriptionRepositoryAPIApiFp(configuration).getConceptDescriptionById(cdIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postConceptDescription(body: ConceptDescription, options?: any) {
            return ConceptDescriptionRepositoryAPIApiFp(configuration).postConceptDescription(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Concept Description
         * @param {ConceptDescription} body Concept Description object
         * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, options?: any) {
            return ConceptDescriptionRepositoryAPIApiFp(configuration).putConceptDescriptionById(body, cdIdentifier, options)(fetch, basePath);
        },
    };
};

/**
 * ConceptDescriptionRepositoryAPIApi - object-oriented interface
 * @export
 * @class ConceptDescriptionRepositoryAPIApi
 * @extends {BaseAPI}
 */
export class ConceptDescriptionRepositoryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a Concept Description
     * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptDescriptionRepositoryAPIApi
     */
    public deleteConceptDescriptionById(cdIdentifier: string, options?: any) {
        return ConceptDescriptionRepositoryAPIApiFp(this.configuration).deleteConceptDescriptionById(cdIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Concept Descriptions
     * @param {string} [idShort] The Concept Descriptions IdShort
     * @param {string} [isCaseOf] IsCaseOf reference (UTF8-BASE64-URL-encoded)
     * @param {string} [dataSpecificationRef] DataSpecification reference (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptDescriptionRepositoryAPIApi
     */
    public getAllConceptDescriptions(idShort?: string, isCaseOf?: string, dataSpecificationRef?: string, limit?: number, cursor?: string, options?: any) {
        return ConceptDescriptionRepositoryAPIApiFp(this.configuration).getAllConceptDescriptions(idShort, isCaseOf, dataSpecificationRef, limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Concept Description
     * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptDescriptionRepositoryAPIApi
     */
    public getConceptDescriptionById(cdIdentifier: string, options?: any) {
        return ConceptDescriptionRepositoryAPIApiFp(this.configuration).getConceptDescriptionById(cdIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Concept Description
     * @param {ConceptDescription} body Concept Description object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptDescriptionRepositoryAPIApi
     */
    public postConceptDescription(body: ConceptDescription, options?: any) {
        return ConceptDescriptionRepositoryAPIApiFp(this.configuration).postConceptDescription(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Concept Description
     * @param {ConceptDescription} body Concept Description object
     * @param {string} cdIdentifier The Concept Descriptions unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConceptDescriptionRepositoryAPIApi
     */
    public putConceptDescriptionById(body: ConceptDescription, cdIdentifier: string, options?: any) {
        return ConceptDescriptionRepositoryAPIApiFp(this.configuration).putConceptDescriptionById(body, cdIdentifier, options)(this.fetch, this.basePath);
    }

}
/**
 * DescriptionAPIApi - fetch parameter creator
 * @export
 */
export const DescriptionAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the self-describing information of a network resource (ServiceDescription)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescription(options: any = {}): FetchArgs {
            const localVarPath = `/description`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DescriptionAPIApi - functional programming interface
 * @export
 */
export const DescriptionAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the self-describing information of a network resource (ServiceDescription)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescription(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServiceDescription> {
            const localVarFetchArgs = DescriptionAPIApiFetchParamCreator(configuration).getDescription(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DescriptionAPIApi - factory interface
 * @export
 */
export const DescriptionAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns the self-describing information of a network resource (ServiceDescription)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDescription(options?: any) {
            return DescriptionAPIApiFp(configuration).getDescription(options)(fetch, basePath);
        },
    };
};

/**
 * DescriptionAPIApi - object-oriented interface
 * @export
 * @class DescriptionAPIApi
 * @extends {BaseAPI}
 */
export class DescriptionAPIApi extends BaseAPI {
    /**
     * 
     * @summary Returns the self-describing information of a network resource (ServiceDescription)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DescriptionAPIApi
     */
    public getDescription(options?: any) {
        return DescriptionAPIApiFp(this.configuration).getDescription(options)(this.fetch, this.basePath);
    }

}
/**
 * SerializationAPIApi - fetch parameter creator
 * @export
 */
export const SerializationAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an appropriate serialization based on the specified format (see SerializationFormat)
         * @param {Array<string>} [aasIds] The Asset Administration Shells&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {Array<string>} [submodelIds] The Submodels&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {boolean} [includeConceptDescriptions] Include Concept Descriptions?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSerializationByIds(aasIds?: Array<string>, submodelIds?: Array<string>, includeConceptDescriptions?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/serialization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (aasIds) {
                localVarQueryParameter['aasIds'] = aasIds;
            }

            if (submodelIds) {
                localVarQueryParameter['submodelIds'] = submodelIds;
            }

            if (includeConceptDescriptions !== undefined) {
                localVarQueryParameter['includeConceptDescriptions'] = includeConceptDescriptions;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SerializationAPIApi - functional programming interface
 * @export
 */
export const SerializationAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns an appropriate serialization based on the specified format (see SerializationFormat)
         * @param {Array<string>} [aasIds] The Asset Administration Shells&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {Array<string>} [submodelIds] The Submodels&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {boolean} [includeConceptDescriptions] Include Concept Descriptions?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSerializationByIds(aasIds?: Array<string>, submodelIds?: Array<string>, includeConceptDescriptions?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = SerializationAPIApiFetchParamCreator(configuration).generateSerializationByIds(aasIds, submodelIds, includeConceptDescriptions, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SerializationAPIApi - factory interface
 * @export
 */
export const SerializationAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns an appropriate serialization based on the specified format (see SerializationFormat)
         * @param {Array<string>} [aasIds] The Asset Administration Shells&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {Array<string>} [submodelIds] The Submodels&#x27; unique ids (UTF8-BASE64-URL-encoded)
         * @param {boolean} [includeConceptDescriptions] Include Concept Descriptions?
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSerializationByIds(aasIds?: Array<string>, submodelIds?: Array<string>, includeConceptDescriptions?: boolean, options?: any) {
            return SerializationAPIApiFp(configuration).generateSerializationByIds(aasIds, submodelIds, includeConceptDescriptions, options)(fetch, basePath);
        },
    };
};

/**
 * SerializationAPIApi - object-oriented interface
 * @export
 * @class SerializationAPIApi
 * @extends {BaseAPI}
 */
export class SerializationAPIApi extends BaseAPI {
    /**
     * 
     * @summary Returns an appropriate serialization based on the specified format (see SerializationFormat)
     * @param {Array<string>} [aasIds] The Asset Administration Shells&#x27; unique ids (UTF8-BASE64-URL-encoded)
     * @param {Array<string>} [submodelIds] The Submodels&#x27; unique ids (UTF8-BASE64-URL-encoded)
     * @param {boolean} [includeConceptDescriptions] Include Concept Descriptions?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SerializationAPIApi
     */
    public generateSerializationByIds(aasIds?: Array<string>, submodelIds?: Array<string>, includeConceptDescriptions?: boolean, options?: any) {
        return SerializationAPIApiFp(this.configuration).generateSerializationByIds(aasIds, submodelIds, includeConceptDescriptions, options)(this.fetch, this.basePath);
    }

}
/**
 * SubmodelAPIApi - fetch parameter creator
 * @export
 */
export const SubmodelAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPath(idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteFileByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPath(idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElements(limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/submodel-elements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadata(limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/submodel-elements/$metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPath(limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/submodel-elements/$path`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReference(limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/submodel-elements/$reference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnly(limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/submodel-elements/$value`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPath(idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getFileByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResult(idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResult.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResult.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/operation-results/{handleId}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnly(idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultValueOnly.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultValueOnly.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/operation-results/{handleId}/$value`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatus(idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncStatus.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncStatus.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/operation-status/{handleId}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodel(level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPath(idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadata(idShortPath: string, cursor?: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathMetadata.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPath(idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$path`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReference(idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathReference.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$reference`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnly(idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathValueOnly.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$value`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadata(level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/$metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel in the Path notation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPath(level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/$path`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Reference of the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelReference(level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/$reference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Submodel in the ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnly(level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel/$value`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperation(body: OperationRequest, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperation.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperation.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/invoke`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsync(body: OperationRequest, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsync.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsync.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/invoke-async`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncValueOnly.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncValueOnly.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/invoke-async/$value`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationSyncValueOnly.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationSyncValueOnly.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/invoke/$value`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodel(body: Submodel, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodel.');
            }
            const localVarPath = `/submodel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPath.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {GetSubmodelElementsMetadataResult} body Metadata attributes of the SubmodelElement
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadata(body: GetSubmodelElementsMetadataResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPathMetadata.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPathMetadata.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetSubmodelElementsMetadataResult" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {GetSubmodelElementsValueResult} body The SubmodelElement in its ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnly(body: GetSubmodelElementsValueResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPathValueOnly.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPathValueOnly.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/$value`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetSubmodelElementsValueResult" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadata(body: SubmodelMetadata, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelMetadata.');
            }
            const localVarPath = `/submodel/$metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the values of the Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnly(body: SubmodelValue, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelValueOnly.');
            }
            const localVarPath = `/submodel/$value`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElement(body: SubmodelElement, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElement.');
            }
            const localVarPath = `/submodel/submodel-elements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPath(body: SubmodelElement, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementByPath.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling postSubmodelElementByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPath(fileName: string, file: Blob, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putFileByPath.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putFileByPath.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putFileByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodel(body: Submodel, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodel.');
            }
            const localVarPath = `/submodel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelElementByPath.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putSubmodelElementByPath.');
            }
            const localVarPath = `/submodel/submodel-elements/{idShortPath}`
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmodelAPIApi - functional programming interface
 * @export
 */
export const SubmodelAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPath(idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).deleteFileByPath(idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPath(idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).deleteSubmodelElementByPath(idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElements(limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getAllSubmodelElements(limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadata(limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsMetadataResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getAllSubmodelElementsMetadata(limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPath(limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPathItemsResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getAllSubmodelElementsPath(limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReference(limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getAllSubmodelElementsReference(limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnly(limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsValueResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getAllSubmodelElementsValueOnly(limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPath(idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getFileByPath(idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResult(idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getOperationAsyncResult(idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnly(idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getOperationAsyncResultValueOnly(idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatus(idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BaseOperationResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getOperationAsyncStatus(idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodel(level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submodel> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodel(level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPath(idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelElementByPath(idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadata(idShortPath: string, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementMetadata> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelElementByPathMetadata(idShortPath, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPath(idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PathItem> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelElementByPathPath(idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReference(idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelElementByPathReference(idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnly(idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementValue> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelElementByPathValueOnly(idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadata(level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelMetadata> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelMetadata(level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel in the Path notation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPath(level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PathItem>> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelPath(level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Reference of the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelReference(level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelReference(level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Submodel in the ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnly(level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelValue> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).getSubmodelValueOnly(level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperation(body: OperationRequest, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).invokeOperation(body, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsync(body: OperationRequest, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).invokeOperationAsync(body, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).invokeOperationAsyncValueOnly(body, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).invokeOperationSyncValueOnly(body, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodel(body: Submodel, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodel(body, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodelElementByPath(body, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {GetSubmodelElementsMetadataResult} body Metadata attributes of the SubmodelElement
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadata(body: GetSubmodelElementsMetadataResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodelElementByPathMetadata(body, idShortPath, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {GetSubmodelElementsValueResult} body The SubmodelElement in its ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnly(body: GetSubmodelElementsValueResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodelElementByPathValueOnly(body, idShortPath, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadata(body: SubmodelMetadata, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodelMetadata(body, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the values of the Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnly(body: SubmodelValue, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).patchSubmodelValueOnly(body, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElement(body: SubmodelElement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).postSubmodelElement(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPath(body: SubmodelElement, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).postSubmodelElementByPath(body, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPath(fileName: string, file: Blob, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).putFileByPath(fileName, file, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodel(body: Submodel, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).putSubmodel(body, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelAPIApiFetchParamCreator(configuration).putSubmodelElementByPath(body, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmodelAPIApi - factory interface
 * @export
 */
export const SubmodelAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPath(idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).deleteFileByPath(idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPath(idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).deleteSubmodelElementByPath(idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElements(limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getAllSubmodelElements(limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadata(limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getAllSubmodelElementsMetadata(limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPath(limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getAllSubmodelElementsPath(limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReference(limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getAllSubmodelElementsReference(limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnly(limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getAllSubmodelElementsValueOnly(limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPath(idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getFileByPath(idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResult(idShortPath: string, handleId: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getOperationAsyncResult(idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the value of the Operation result of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnly(idShortPath: string, handleId: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getOperationAsyncResultValueOnly(idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatus(idShortPath: string, handleId: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getOperationAsyncStatus(idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodel(level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodel(level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPath(idShortPath: string, level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelElementByPath(idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadata(idShortPath: string, cursor?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelElementByPathMetadata(idShortPath, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPath(idShortPath: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelElementByPathPath(idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReference(idShortPath: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelElementByPathReference(idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnly(idShortPath: string, level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelElementByPathValueOnly(idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelMetadata(level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelMetadata(level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel in the Path notation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelPath(level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelPath(level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Reference of the Submodel
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelReference(level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelReference(level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Submodel in the ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelValueOnly(level?: string, extent?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).getSubmodelValueOnly(level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperation(body: OperationRequest, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).invokeOperation(body, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsync(body: OperationRequest, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).invokeOperationAsync(body, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).invokeOperationAsyncValueOnly(body, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).invokeOperationSyncValueOnly(body, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodel(body: Submodel, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodel(body, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodelElementByPath(body, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {GetSubmodelElementsMetadataResult} body Metadata attributes of the SubmodelElement
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadata(body: GetSubmodelElementsMetadataResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodelElementByPathMetadata(body, idShortPath, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {GetSubmodelElementsValueResult} body The SubmodelElement in its ValueOnly representation
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnly(body: GetSubmodelElementsValueResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodelElementByPathValueOnly(body, idShortPath, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of the Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelMetadata(body: SubmodelMetadata, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodelMetadata(body, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the values of the Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelValueOnly(body: SubmodelValue, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).patchSubmodelValueOnly(body, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElement(body: SubmodelElement, options?: any) {
            return SubmodelAPIApiFp(configuration).postSubmodelElement(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPath(body: SubmodelElement, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).postSubmodelElementByPath(body, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPath(fileName: string, file: Blob, idShortPath: string, options?: any) {
            return SubmodelAPIApiFp(configuration).putFileByPath(fileName, file, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the Submodel
         * @param {Submodel} body Submodel object
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodel(body: Submodel, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).putSubmodel(body, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any) {
            return SubmodelAPIApiFp(configuration).putSubmodelElementByPath(body, idShortPath, level, options)(fetch, basePath);
        },
    };
};

/**
 * SubmodelAPIApi - object-oriented interface
 * @export
 * @class SubmodelAPIApi
 * @extends {BaseAPI}
 */
export class SubmodelAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public deleteFileByPath(idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).deleteFileByPath(idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public deleteSubmodelElementByPath(idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).deleteSubmodelElementByPath(idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getAllSubmodelElements(limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getAllSubmodelElements(limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes of all submodel elements including their hierarchy
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getAllSubmodelElementsMetadata(limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getAllSubmodelElementsMetadata(limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the Path notation
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getAllSubmodelElementsPath(limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getAllSubmodelElementsPath(limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the References of all submodel elements
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getAllSubmodelElementsReference(limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getAllSubmodelElementsReference(limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getAllSubmodelElementsValueOnly(limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getAllSubmodelElementsValueOnly(limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getFileByPath(idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getFileByPath(idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation result of an asynchronous invoked Operation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getOperationAsyncResult(idShortPath: string, handleId: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getOperationAsyncResult(idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the value of the Operation result of an asynchronous invoked Operation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getOperationAsyncResultValueOnly(idShortPath: string, handleId: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getOperationAsyncResultValueOnly(idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation status of an asynchronous invoked Operation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getOperationAsyncStatus(idShortPath: string, handleId: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getOperationAsyncStatus(idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodel(level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodel(level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelElementByPath(idShortPath: string, level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelElementByPath(idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelElementByPathMetadata(idShortPath: string, cursor?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelElementByPathMetadata(idShortPath, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelElementByPathPath(idShortPath: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelElementByPathPath(idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelElementByPathReference(idShortPath: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelElementByPathReference(idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelElementByPathValueOnly(idShortPath: string, level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelElementByPathValueOnly(idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes of a specific Submodel
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelMetadata(level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelMetadata(level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel in the Path notation
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelPath(level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelPath(level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Reference of the Submodel
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelReference(level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelReference(level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Submodel in the ValueOnly representation
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public getSubmodelValueOnly(level?: string, extent?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).getSubmodelValueOnly(level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public invokeOperation(body: OperationRequest, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).invokeOperation(body, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public invokeOperationAsync(body: OperationRequest, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).invokeOperationAsync(body, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public invokeOperationAsyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).invokeOperationAsyncValueOnly(body, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public invokeOperationSyncValueOnly(body: OperationRequestValueOnly, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).invokeOperationSyncValueOnly(body, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodel(body: Submodel, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodel(body, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing SubmodelElement
     * @param {SubmodelElement} body SubmodelElement object
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodelElementByPath(body, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes an existing SubmodelElement
     * @param {GetSubmodelElementsMetadataResult} body Metadata attributes of the SubmodelElement
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodelElementByPathMetadata(body: GetSubmodelElementsMetadataResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodelElementByPathMetadata(body, idShortPath, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the value of an existing SubmodelElement
     * @param {GetSubmodelElementsValueResult} body The SubmodelElement in its ValueOnly representation
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodelElementByPathValueOnly(body: GetSubmodelElementsValueResult, idShortPath: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodelElementByPathValueOnly(body, idShortPath, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of the Submodel
     * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodelMetadata(body: SubmodelMetadata, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodelMetadata(body, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the values of the Submodel
     * @param {SubmodelValue} body Submodel object in its ValueOnly representation
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public patchSubmodelValueOnly(body: SubmodelValue, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).patchSubmodelValueOnly(body, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element
     * @param {SubmodelElement} body Requested submodel element
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public postSubmodelElement(body: SubmodelElement, options?: any) {
        return SubmodelAPIApiFp(this.configuration).postSubmodelElement(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public postSubmodelElementByPath(body: SubmodelElement, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).postSubmodelElementByPath(body, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public putFileByPath(fileName: string, file: Blob, idShortPath: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).putFileByPath(fileName, file, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the Submodel
     * @param {Submodel} body Submodel object
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public putSubmodel(body: Submodel, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).putSubmodel(body, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelAPIApi
     */
    public putSubmodelElementByPath(body: SubmodelElement, idShortPath: string, level?: string, options?: any) {
        return SubmodelAPIApiFp(this.configuration).putSubmodelElementByPath(body, idShortPath, level, options)(this.fetch, this.basePath);
    }

}
/**
 * SubmodelRegistryAPIApi - fetch parameter creator
 * @export
 */
export const SubmodelRegistryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorById(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelDescriptorById.');
            }
            const localVarPath = `/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptors(limit?: number, cursor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodel-descriptors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorById(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelDescriptorById.');
            }
            const localVarPath = `/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptor(body: SubmodelDescriptor, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelDescriptor.');
            }
            const localVarPath = `/submodel-descriptors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorById(body: SubmodelDescriptor, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelDescriptorById.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelDescriptorById.');
            }
            const localVarPath = `/submodel-descriptors/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelDescriptor" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmodelRegistryAPIApi - functional programming interface
 * @export
 */
export const SubmodelRegistryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorById(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRegistryAPIApiFetchParamCreator(configuration).deleteSubmodelDescriptorById(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptors(limit?: number, cursor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelDescriptorsResult> {
            const localVarFetchArgs = SubmodelRegistryAPIApiFetchParamCreator(configuration).getAllSubmodelDescriptors(limit, cursor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorById(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelDescriptor> {
            const localVarFetchArgs = SubmodelRegistryAPIApiFetchParamCreator(configuration).getSubmodelDescriptorById(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptor(body: SubmodelDescriptor, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelDescriptor> {
            const localVarFetchArgs = SubmodelRegistryAPIApiFetchParamCreator(configuration).postSubmodelDescriptor(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorById(body: SubmodelDescriptor, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRegistryAPIApiFetchParamCreator(configuration).putSubmodelDescriptorById(body, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmodelRegistryAPIApi - factory interface
 * @export
 */
export const SubmodelRegistryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelDescriptorById(submodelIdentifier: string, options?: any) {
            return SubmodelRegistryAPIApiFp(configuration).deleteSubmodelDescriptorById(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Submodel Descriptors
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelDescriptors(limit?: number, cursor?: string, options?: any) {
            return SubmodelRegistryAPIApiFp(configuration).getAllSubmodelDescriptors(limit, cursor, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Submodel Descriptor
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelDescriptorById(submodelIdentifier: string, options?: any) {
            return SubmodelRegistryAPIApiFp(configuration).getSubmodelDescriptorById(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelDescriptor(body: SubmodelDescriptor, options?: any) {
            return SubmodelRegistryAPIApiFp(configuration).postSubmodelDescriptor(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Submodel Descriptor
         * @param {SubmodelDescriptor} body Submodel Descriptor object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelDescriptorById(body: SubmodelDescriptor, submodelIdentifier: string, options?: any) {
            return SubmodelRegistryAPIApiFp(configuration).putSubmodelDescriptorById(body, submodelIdentifier, options)(fetch, basePath);
        },
    };
};

/**
 * SubmodelRegistryAPIApi - object-oriented interface
 * @export
 * @class SubmodelRegistryAPIApi
 * @extends {BaseAPI}
 */
export class SubmodelRegistryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a Submodel Descriptor, i.e. de-registers a submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRegistryAPIApi
     */
    public deleteSubmodelDescriptorById(submodelIdentifier: string, options?: any) {
        return SubmodelRegistryAPIApiFp(this.configuration).deleteSubmodelDescriptorById(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Submodel Descriptors
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRegistryAPIApi
     */
    public getAllSubmodelDescriptors(limit?: number, cursor?: string, options?: any) {
        return SubmodelRegistryAPIApiFp(this.configuration).getAllSubmodelDescriptors(limit, cursor, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Submodel Descriptor
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRegistryAPIApi
     */
    public getSubmodelDescriptorById(submodelIdentifier: string, options?: any) {
        return SubmodelRegistryAPIApiFp(this.configuration).getSubmodelDescriptorById(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Submodel Descriptor, i.e. registers a submodel
     * @param {SubmodelDescriptor} body Submodel Descriptor object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRegistryAPIApi
     */
    public postSubmodelDescriptor(body: SubmodelDescriptor, options?: any) {
        return SubmodelRegistryAPIApiFp(this.configuration).postSubmodelDescriptor(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Submodel Descriptor
     * @param {SubmodelDescriptor} body Submodel Descriptor object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRegistryAPIApi
     */
    public putSubmodelDescriptorById(body: SubmodelDescriptor, submodelIdentifier: string, options?: any) {
        return SubmodelRegistryAPIApiFp(this.configuration).putSubmodelDescriptorById(body, submodelIdentifier, options)(this.fetch, this.basePath);
    }

}
/**
 * SubmodelRepositoryAPIApi - fetch parameter creator
 * @export
 */
export const SubmodelRepositoryAPIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteFileByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteFileByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelById(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelById.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling deleteSubmodelElementByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsMetadataSubmodelRepository.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsReferenceSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsSubmodelRepository.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getAllSubmodelElementsValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodels(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (semanticId !== undefined) {
                localVarQueryParameter['semanticId'] = semanticId;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsMetadata(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodels/$metadata`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (semanticId !== undefined) {
                localVarQueryParameter['semanticId'] = semanticId;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Submodels in the Path notation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsPath(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodels/$path`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (semanticId !== undefined) {
                localVarQueryParameter['semanticId'] = semanticId;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the References for all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsReference(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodels/$reference`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (semanticId !== undefined) {
                localVarQueryParameter['semanticId'] = semanticId;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all Submodels in their ValueOnly representation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsValueOnly(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submodels/$value`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (semanticId !== undefined) {
                localVarQueryParameter['semanticId'] = semanticId;
            }

            if (idShort !== undefined) {
                localVarQueryParameter['idShort'] = idShort;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getFileByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getFileByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncResultValueOnlySubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncResultValueOnlySubmodelRepo.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncResultValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-results/{handleId}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getOperationAsyncStatusSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getOperationAsyncStatusSubmodelRepo.');
            }
            // verify required parameter 'handleId' is not null or undefined
            if (handleId === null || handleId === undefined) {
                throw new RequiredError('handleId','Required parameter handleId was null or undefined when calling getOperationAsyncStatusSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/operation-status/{handleId}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)))
                .replace(`{${"handleId"}}`, encodeURIComponent(String(handleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelById(submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelById.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadata(submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdMetadata.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPath(submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdPath.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReference(submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdReference.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnly(submodelIdentifier: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelByIdValueOnly.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathMetadataSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathMetadataSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$path`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathReferenceSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathReferenceSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$reference`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling getSubmodelElementByPathValueOnlySubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling getSubmodelElementByPathValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (extent !== undefined) {
                localVarQueryParameter['extent'] = extent;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationAsyncValueOnlySubmodelRepo.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationAsyncValueOnlySubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationAsyncValueOnlySubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationAsyncValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke-async/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling invokeOperationValueOnlySubmodelRepo.');
            }
            // verify required parameter 'aasIdentifier' is not null or undefined
            if (aasIdentifier === null || aasIdentifier === undefined) {
                throw new RequiredError('aasIdentifier','Required parameter aasIdentifier was null or undefined when calling invokeOperationValueOnlySubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling invokeOperationValueOnlySubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling invokeOperationValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/invoke/$value`
                .replace(`{${"aasIdentifier"}}`, encodeURIComponent(String(aasIdentifier)))
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OperationRequestValueOnly" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelById(body: Submodel, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelById.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelById.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadata(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelByIdMetadata.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelByIdMetadata.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the values of an existing Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnly(body: SubmodelValue, submodelIdentifier: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelByIdValueOnly.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelByIdValueOnly.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {SubmodelElementMetadata} body Metadata attributes of the SubmodelElement
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadataSubmodelRepo(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPathMetadataSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$metadata`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementMetadata" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {SubmodelElementValue} body The SubmodelElement in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnlySubmodelRepo(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling patchSubmodelElementByPathValueOnlySubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/$value`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElementValue" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Submodel
         * @param {Submodel} body Submodel object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodel(body: Submodel, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodel.');
            }
            const localVarPath = `/submodels`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling postSubmodelElementByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementSubmodelRepository(body: SubmodelElement, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling postSubmodelElementSubmodelRepository.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling postSubmodelElementSubmodelRepository.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathSubmodelRepo(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling putFileByPathSubmodelRepo.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling putFileByPathSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putFileByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putFileByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}/attachment`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (fileName !== undefined) {
                localVarFormParams.set('fileName', fileName as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelById(body: Submodel, submodelIdentifier: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelById.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelById.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submodel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'submodelIdentifier' is not null or undefined
            if (submodelIdentifier === null || submodelIdentifier === undefined) {
                throw new RequiredError('submodelIdentifier','Required parameter submodelIdentifier was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
            }
            // verify required parameter 'idShortPath' is not null or undefined
            if (idShortPath === null || idShortPath === undefined) {
                throw new RequiredError('idShortPath','Required parameter idShortPath was null or undefined when calling putSubmodelElementByPathSubmodelRepo.');
            }
            const localVarPath = `/submodels/{submodelIdentifier}/submodel-elements/{idShortPath}`
                .replace(`{${"submodelIdentifier"}}`, encodeURIComponent(String(submodelIdentifier)))
                .replace(`{${"idShortPath"}}`, encodeURIComponent(String(idShortPath)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmodelElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmodelRepositoryAPIApi - functional programming interface
 * @export
 */
export const SubmodelRepositoryAPIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).deleteFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelById(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).deleteSubmodelById(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsMetadataResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPathItemsResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsSubmodelRepository(submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelElementsValueResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodels(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelsResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodels(semanticId, idShort, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsMetadata(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelsMetadataResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelsMetadata(semanticId, idShort, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Submodels in the Path notation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsPath(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPathItemsResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelsPath(semanticId, idShort, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the References for all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsReference(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetReferencesResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelsReference(semanticId, idShort, limit, cursor, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns all Submodels in their ValueOnly representation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsValueOnly(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetSubmodelsValueResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getAllSubmodelsValueOnly(semanticId, idShort, limit, cursor, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncResultSubmodelRepo(submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getOperationAsyncStatusSubmodelRepo(submodelIdentifier, idShortPath, handleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelById(submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submodel> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelById(submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadata(submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelMetadata> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdMetadata(submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPath(submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PathItem>> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdPath(submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Reference of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReference(submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdReference(submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific Submodel in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnly(submodelIdentifier: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelValue> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelByIdValueOnly(submodelIdentifier, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementMetadata> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PathItem>> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Reference> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElementValue> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier, idShortPath, level, extent, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).invokeOperationAsyncSubmodelRepo(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).invokeOperationAsyncValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResult> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).invokeOperationSubmodelRepo(body, submodelIdentifier, idShortPath, async, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationResultValueOnly> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).invokeOperationValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, async, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelById(body: Submodel, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelById(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadata(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelByIdMetadata(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the values of an existing Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnly(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelByIdValueOnly(body, submodelIdentifier, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {SubmodelElementMetadata} body Metadata attributes of the SubmodelElement
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadataSubmodelRepo(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementByPathMetadataSubmodelRepo(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {SubmodelElementValue} body The SubmodelElement in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnlySubmodelRepo(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).patchSubmodelElementByPathValueOnlySubmodelRepo(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Submodel
         * @param {Submodel} body Submodel object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodel(body: Submodel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submodel> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).postSubmodel(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).postSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementSubmodelRepository(body: SubmodelElement, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SubmodelElement> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).postSubmodelElementSubmodelRepository(body, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathSubmodelRepo(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).putFileByPathSubmodelRepo(fileName, file, submodelIdentifier, idShortPath, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelById(body: Submodel, submodelIdentifier: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).putSubmodelById(body, submodelIdentifier, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmodelRepositoryAPIApiFetchParamCreator(configuration).putSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmodelRepositoryAPIApi - factory interface
 * @export
 */
export const SubmodelRepositoryAPIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).deleteFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelById(submodelIdentifier: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).deleteSubmodelById(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes of all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the References of all submodel elements
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelElementsSubmodelRepository(submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodels(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodels(semanticId, idShort, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes of all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsMetadata(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelsMetadata(semanticId, idShort, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Submodels in the Path notation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsPath(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelsPath(semanticId, idShort, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the References for all Submodels
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsReference(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelsReference(semanticId, idShort, limit, cursor, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns all Submodels in their ValueOnly representation
         * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
         * @param {string} [idShort] The Asset Administration Shells IdShort
         * @param {number} [limit] The maximum number of elements in the response array
         * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSubmodelsValueOnly(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getAllSubmodelsValueOnly(semanticId, idShort, limit, cursor, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getOperationAsyncResultSubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation result of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Operation status of an asynchronous invoked Operation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOperationAsyncStatusSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getOperationAsyncStatusSubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelById(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelById(submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the metadata attributes of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdMetadata(submodelIdentifier: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelByIdMetadata(submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Submodel in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdPath(submodelIdentifier: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelByIdPath(submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Reference of a specific Submodel
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdReference(submodelIdentifier: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelByIdReference(submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific Submodel in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelByIdValueOnly(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelByIdValueOnly(submodelIdentifier, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {string} [extent] Determines to which extent the resource is being serialized
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier, idShortPath, level, extent, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).invokeOperationAsyncSubmodelRepo(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Asynchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationAsyncValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).invokeOperationAsyncValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequest} body Operation request object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).invokeOperationSubmodelRepo(body, submodelIdentifier, idShortPath, async, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Synchronously invokes an Operation at a specified path
         * @param {OperationRequestValueOnly} body Operation request object
         * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invokeOperationValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).invokeOperationValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, async, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelById(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelById(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes of an existing Submodel
         * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdMetadata(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelByIdMetadata(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the values of an existing Submodel
         * @param {SubmodelValue} body Submodel object in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelByIdValueOnly(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelByIdValueOnly(body, submodelIdentifier, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the metadata attributes an existing SubmodelElement
         * @param {SubmodelElementMetadata} body Metadata attributes of the SubmodelElement
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathMetadataSubmodelRepo(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelElementByPathMetadataSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing SubmodelElement
         * @param {SubmodelElement} body SubmodelElement object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the value of an existing SubmodelElement
         * @param {SubmodelElementValue} body The SubmodelElement in its ValueOnly representation
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchSubmodelElementByPathValueOnlySubmodelRepo(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).patchSubmodelElementByPathValueOnlySubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Submodel
         * @param {Submodel} body Submodel object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodel(body: Submodel, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).postSubmodel(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).postSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new submodel element
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmodelElementSubmodelRepository(body: SubmodelElement, submodelIdentifier: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).postSubmodelElementSubmodelRepository(body, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
         * @param {string} fileName 
         * @param {Blob} file 
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFileByPathSubmodelRepo(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).putFileByPathSubmodelRepo(fileName, file, submodelIdentifier, idShortPath, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing Submodel
         * @param {Submodel} body Submodel object
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelById(body: Submodel, submodelIdentifier: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).putSubmodelById(body, submodelIdentifier, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
         * @param {SubmodelElement} body Requested submodel element
         * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
         * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
         * @param {string} [level] Determines the structural depth of the respective resource content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
            return SubmodelRepositoryAPIApiFp(configuration).putSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(fetch, basePath);
        },
    };
};

/**
 * SubmodelRepositoryAPIApi - object-oriented interface
 * @export
 * @class SubmodelRepositoryAPIApi
 * @extends {BaseAPI}
 */
export class SubmodelRepositoryAPIApi extends BaseAPI {
    /**
     * 
     * @summary Deletes file content of an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public deleteFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).deleteFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a Submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public deleteSubmodelById(submodelIdentifier: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).deleteSubmodelById(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a submodel element at a specified path within the submodel elements hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).deleteSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes of all submodel elements including their hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsMetadataSubmodelRepository(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the Path notation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsPathSubmodelRepo(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the References of all submodel elements
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsReferenceSubmodelRepo(submodelIdentifier, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelElementsSubmodelRepository(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsSubmodelRepository(submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all submodel elements including their hierarchy in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelElementsValueOnlySubmodelRepo(submodelIdentifier, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Submodels
     * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodels(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodels(semanticId, idShort, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes of all Submodels
     * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelsMetadata(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelsMetadata(semanticId, idShort, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Submodels in the Path notation
     * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelsPath(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelsPath(semanticId, idShort, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the References for all Submodels
     * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelsReference(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelsReference(semanticId, idShort, limit, cursor, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns all Submodels in their ValueOnly representation
     * @param {string} [semanticId] The value of the semantic id reference (BASE64-URL-encoded)
     * @param {string} [idShort] The Asset Administration Shells IdShort
     * @param {number} [limit] The maximum number of elements in the response array
     * @param {string} [cursor] A server-generated identifier retrieved from pagingMetadata that specifies from which position the result listing should continue
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getAllSubmodelsValueOnly(semanticId?: string, idShort?: string, limit?: number, cursor?: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getAllSubmodelsValueOnly(semanticId, idShort, limit, cursor, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Downloads file content from a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getFileByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getFileByPathSubmodelRepo(submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation result of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getOperationAsyncResultSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getOperationAsyncResultSubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation result of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getOperationAsyncResultValueOnlySubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Operation status of an asynchronous invoked Operation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} handleId The returned handle id of an operations asynchronous invocation used to request the current state of the operations execution (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getOperationAsyncStatusSubmodelRepo(submodelIdentifier: string, idShortPath: string, handleId: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getOperationAsyncStatusSubmodelRepo(submodelIdentifier, idShortPath, handleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelById(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelById(submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the metadata attributes of a specific Submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelByIdMetadata(submodelIdentifier: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelByIdMetadata(submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Submodel in the Path notation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelByIdPath(submodelIdentifier: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelByIdPath(submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Reference of a specific Submodel
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelByIdReference(submodelIdentifier: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelByIdReference(submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific Submodel in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelByIdValueOnly(submodelIdentifier: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelByIdValueOnly(submodelIdentifier, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the matadata attributes of a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathMetadataSubmodelRepo(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the Path notation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathPathSubmodelRepo(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns the Referene of a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathReferenceSubmodelRepo(submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelElementByPathSubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathSubmodelRepo(submodelIdentifier, idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a specific submodel element from the Submodel at a specified path in the ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {string} [extent] Determines to which extent the resource is being serialized
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier: string, idShortPath: string, level?: string, extent?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).getSubmodelElementByPathValueOnlySubmodelRepo(submodelIdentifier, idShortPath, level, extent, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public invokeOperationAsyncSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).invokeOperationAsyncSubmodelRepo(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Asynchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public invokeOperationAsyncValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).invokeOperationAsyncValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequest} body Operation request object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public invokeOperationSubmodelRepo(body: OperationRequest, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).invokeOperationSubmodelRepo(body, submodelIdentifier, idShortPath, async, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Synchronously invokes an Operation at a specified path
     * @param {OperationRequestValueOnly} body Operation request object
     * @param {string} aasIdentifier The Asset Administration Shells unique id (UTF8-BASE64-URL-encoded)
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {boolean} [async] Determines whether an operation invocation is performed asynchronously or synchronously
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public invokeOperationValueOnlySubmodelRepo(body: OperationRequestValueOnly, aasIdentifier: string, submodelIdentifier: string, idShortPath: string, async?: boolean, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).invokeOperationValueOnlySubmodelRepo(body, aasIdentifier, submodelIdentifier, idShortPath, async, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Submodel
     * @param {Submodel} body Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelById(body: Submodel, submodelIdentifier: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelById(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes of an existing Submodel
     * @param {SubmodelMetadata} body The metadata attributes of the Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelByIdMetadata(body: SubmodelMetadata, submodelIdentifier: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelByIdMetadata(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the values of an existing Submodel
     * @param {SubmodelValue} body Submodel object in its ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelByIdValueOnly(body: SubmodelValue, submodelIdentifier: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelByIdValueOnly(body, submodelIdentifier, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the metadata attributes an existing SubmodelElement
     * @param {SubmodelElementMetadata} body Metadata attributes of the SubmodelElement
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelElementByPathMetadataSubmodelRepo(body: SubmodelElementMetadata, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelElementByPathMetadataSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing SubmodelElement
     * @param {SubmodelElement} body SubmodelElement object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the value of an existing SubmodelElement
     * @param {SubmodelElementValue} body The SubmodelElement in its ValueOnly representation
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public patchSubmodelElementByPathValueOnlySubmodelRepo(body: SubmodelElementValue, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).patchSubmodelElementByPathValueOnlySubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Submodel
     * @param {Submodel} body Submodel object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public postSubmodel(body: Submodel, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).postSubmodel(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public postSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).postSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new submodel element
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public postSubmodelElementSubmodelRepository(body: SubmodelElement, submodelIdentifier: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).postSubmodelElementSubmodelRepository(body, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads file content to an existing submodel element at a specified path within submodel elements hierarchy
     * @param {string} fileName 
     * @param {Blob} file 
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public putFileByPathSubmodelRepo(fileName: string, file: Blob, submodelIdentifier: string, idShortPath: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).putFileByPathSubmodelRepo(fileName, file, submodelIdentifier, idShortPath, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing Submodel
     * @param {Submodel} body Submodel object
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public putSubmodelById(body: Submodel, submodelIdentifier: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).putSubmodelById(body, submodelIdentifier, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an existing submodel element at a specified path within submodel elements hierarchy
     * @param {SubmodelElement} body Requested submodel element
     * @param {string} submodelIdentifier The Submodels unique id (UTF8-BASE64-URL-encoded)
     * @param {string} idShortPath IdShort path to the submodel element (dot-separated)
     * @param {string} [level] Determines the structural depth of the respective resource content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmodelRepositoryAPIApi
     */
    public putSubmodelElementByPathSubmodelRepo(body: SubmodelElement, submodelIdentifier: string, idShortPath: string, level?: string, options?: any) {
        return SubmodelRepositoryAPIApiFp(this.configuration).putSubmodelElementByPathSubmodelRepo(body, submodelIdentifier, idShortPath, level, options)(this.fetch, this.basePath);
    }

}
